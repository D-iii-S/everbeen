<?xml version="1.0" encoding="UTF-8"?>

<sect1
	xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xml="http://www.w3.org/XML/1998/namespace"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xsi:schemaLocation="http://docbook.org/ns/docbook ../../../docbook-5.0/xsd/docbook.xsd"
>
	<title>Overview</title>
	
	<para>This section summarizes basic facts about the Task Tree and its integration with the BEEN
	framework.</para>

	<sect2>
		<title>BEEN Framework Integration</title>
		
		<para>The Task Tree is a subcomponent of the Task Manager. It is not a BEEN
		<glossterm>task</glossterm>. It is just
		a passive data structure that provides a public API and stores and retrieves data. There
		are no active processes (threads) related to the tree.</para>
		
		<para>New tasks are assigned a <glossterm>tree address</glossterm> by the
		<glossterm>generator</glossterm> that creates them. The Task Manager stores new tasks
		in the task tree automatically, making them accessible (and identifiable) by their tree addresses
		and making them visible when the Task Tree is listed. The tree leaf representing the task
		is cleaned up when data of finished tasks is discarded.</para>
		
		<para>The Task Tree can be accessed through RMI outside the Task Manager. References can be
		obtained from Task Manager's public interface.
		The implementation is thread-safe and can be both queried and updated by multiple threads
		at the same time. It exposes two public interfaces,
		<interfacename>TaskTreeQuery</interfacename> for read-only operations and
		<interfacename>TaskTreeInput</interfacename> for write-only operations.</para>
		
		<para>All the Task Tree code resides in the <package>cz.cuni.mff.been.taskmanager.tasktree</package>
		package. It has no external dependencies and does not interact with other components of BEEN
		actively.</para>
	</sect2>	

	<sect2>
		<title>How the Task Tree Operates</title>
		
		<para>The data structure consists of three closely integrated parts. Address handling code
		stores and resolves tree addresses efficiently. Structure handling code maintains
		the representation of the tree structure. Flags handling code takes care of flag udpate
		operations.</para>
		
		<sect3>
			<title>Address Handling Code</title>
			
			<para>Instances of the <classname>TaskTreeAddress</classname> class can only be produced
			internally by the Task Tree. When a component wants to manipulate a tree node, it has to
			obtain the address object first. The tree will issue an address object based on a
			<glossterm baseform="task tree path">path string</glossterm>. The structure of path strings is described in
			User Documentation, <xref linkend="been.user.execution.tasks.tree"/>. (For example,
			<code>/this/is/a/path</code> could be a path string.)</para>
			
			<para>The structure of path strings is slightly different from UNIX diretory paths.
			Each path segment contains exactly one slash. Unlike UNIX conventions, double slashes
			are not accepted and the path cannot end with a slash, because this would create
			an empty path segment, which is not allowed. The most importantly, these path conventions
			imply that <emphasis role="strong">the root node is represented by an empty string</emphasis>
			instead of a slash.</para>
			
			<para>The address objects (<classname>TaskTreeAddress</classname>), to which path strings
			are mapped, are just blackboxes containing one <classname>long</classname> value
			inside. This long value is a hash code used by the tree to look up the referenced node
			in its data structures. This means that most tree queries run in
			<emphasis>O(1)</emphasis> time, no matter how deep the node or leaf is located.</para>
			
			<para>The address handling code is thread-safe and guarantees that there is always a
			one-to-one mapping between path strings and hash codes stored in
			<classname>TaskTreeAddress</classname> objects. When two address objects are equal,
			they both represent the same path string. This rule holds in the whole BEEN framework,
			for there is always exactly one Task Manager with exactly one Task Tree.</para>
			
			<para>All valid tree paths can be translated to address objects, no matter if the
			corresponding tree nodes exist or not. (When a new leaf or node is created, its address
			must be obtained first.) Most tree operations take a <classname>TaskTreeAddress</classname>
			argument.</para>
			
			<para>Tree addresses are represnted by <classname>TaskTreeAddressBody</classname>
			in the internal database of addresses.
			This class contains the path string and the hash code assigned to the
			address and implements path string parser methods.</para>
		</sect3>
		
		<sect3>
			<title>Structure Handling Code</title>
		
			<para>Most of this code is concentrated in the <classname>TaskTree</classname> class. Nodes and
			leaves are implemented using helper classes and interfaces, such as
			<interfacename>TaskTreeItem</interfacename>, <classname>TaskTreeBasic</classname>,
			<classname>TaskTreeNode</classname> and <classname>TaskTreeLeaf</classname>.</para>
			
			<para>There are two types of records (items) in the tree: nodes and leaves.
			The (internal) nodes are similar to directories in a file system.
			They contain references to child nodes, which can be both leaves and other
			nodes, and information on all flag values assigned by the aggregate functions
			(<glossterm baseform="inheritance rule">inheritance rules</glossterm>). Tree leaves
			represent <glossterm baseform="task">tasks</glossterm> and contain a reference to
			Task Manager's <classname>TaskEntry</classname> instances. If the tree was a file
			system, leaves would represent files.</para>
			
			<para>Since direct access to leaves and nodes using a <classname>TaskTreeAddress</classname>
			is very fast (<emphasis>O(1)</emphasis>), the only reasons why the tree structure is (physically)
			maintained are (1) efficient listing of nodes and their descendants and (2) implementation
			of the tree flag inheritance mechanism.</para>
			
			<para>The structure handling code uses read-write locks to increase throughput on parallel
			access. Multiple readers can manipulate the tree in parallel. Note that the algorithm
			that evaluates inheritance rules is also a reader, because it does not modify the
			physical structure of the tree in any way. Methods that add or remove nodes or leaves
			have to lock the tree for exclusive access to protect the underlying data structures.</para>
			
			<para>As already mentioned, tree address objects might point at leaves and nodes that
			do not exist. When these new leaves or nodes are added, the complete path is constructed
			as well. (It is similar to how the <command>mkdir -p</command> command operates.)</para>
			
			<para>The tree supports both adding and removal of leaves and nodes, both in a
			thread-safe manner.</para>
		</sect3>
		
		<sect3>
			<title>Flags Handling Code</title>
			
			<para>Classes implementing the <interfacename>TaskTreeFlag</interfacename> interface
			can be used as tree flags. A tree flag is not a boolean value. Instead, its string
			representation (obtained from <methodname>toString()</methodname>) is used as an
			identifier that maps to a pair of values, a <interfacename>Serializable</interfacename> and an
			<classname>Enum&lt;?&gt;</classname>.</para>
			
			<para>Values of Task Tree flags can only be assigned to leaves. Values assigned to flags
			in all the internal nodes are maintained automatically by the tree inheritance
			algorithm. For each node on the path to the root, the <methodname>inherit()</methodname>
			method of the flag that has been modified is invoked. The implementation of this method
			can inspect the flag values in child nodes and adjust the value of their parent when
			necessary.</para>
			
			<para>Since the inheritance algorithm does not modify the tree structure in any way,
			it only needs to acquire the read lock on the structure. Consequently, multiple threads
			can update the flags in parallel. As far as they access different parts of the tree,
			there is no need for mutual exclusion. When multiple threads meet on a single tree node,
			only one of them can perform the update operation at a time. It is guaranteed that
			the <methodname>inherit()</methodname> method always has exclusive access to the node it
			is supposed to update.</para>
			
			<para>Note that flag values assigned to child nodes may change when the
			<methodname>inherit()</methodname> method is running. This may cause the flag value
			assigned to the parent node to be temporarily inconsistent with values in child nodes.
			However, since access to a single node is synchronized, the last one of the waiting
			threads always restores a consistent state. Consequently, when no flag upates are on the
			way (no threads are currently manipulating the flags), the flag state in the whole
			tree is consistent.</para>
			
			<para>It is worth noting that tree traversal usually moves from parents to children,
			whereas flag updates always move from children to parents. This is a second reason
			why values of flags in task tree listings can be temporarily inconsistent. The only way
			to eliminate this problem would be mutual exclusion of all threads working with tree flags, which
			should be avoided for performance reasons. Possible temporary inconsistencies in flag values 
			only affect the ouput shown by the Web Interface or the Command Line Interface. They
			cannot do any harm to other parts of the BEEN framework.</para>
			
			<para>The <quote>lazy</quote> locking algorithm mentioned above is implemented in the
			<methodname>TaskTree.setFlagNonblocking()</methodname> metod. It saves time
			by locking only nodes on the path to the root instead of all descendants of each of
			them.</para>
		</sect3>
	</sect2>	
</sect1>