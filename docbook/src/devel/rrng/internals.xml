<?xml version="1.0" encoding="UTF-8"?>

<sect1
	xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xml="http://www.w3.org/XML/1998/namespace"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xsi:schemaLocation="http://docbook.org/ns/docbook ../../../docbook-5.0/xsd/docbook.xsd"
>
	<title>Results Repository Internals</title>
	
	<sect2>
		<title>Storage Implementation</title>
		<para>
		<glossterm>Results Repository</glossterm> uses Hibernate to persist <glossterm>dataset</glossterm> and <glossterm>trigger</glossterm> metadata and also 
		datasets' data itself. Datasets and triggers are persisted as regular Hibernate 
		entities. Since <glossterm>datasets</glossterm> have customizable fields and we want them to be indexable 
		(and thus searchable efficiently), the implementation is following: for every dataset 
		an entity class with appropriate fields (and annotations) is created using OW2 ASM framework.
		 Over this entity, a new Hibernate session factory is opened and all load- and save- calls 
		 are handled by this session factory.
		</para>
		
		
		<sect3>
			<title>Derby DB</title>
			<para>
			Apache Derby DB in embedded mode is used to make all datasets' data persistent
			(both dataset data and dataset/trigger metadata are stored using Derby).
			</para>
			<para>
			Derby home is located in working directory of <glossterm>Results Repository Service</glossterm>. By default, name of
			database used to store all <glossterm>Results Repository</glossterm> data is <filename>ResultsRepositoryDB</filename>.
			To backup all RR's data, it's enough to shutdown RR and copy RR's database
			and <glossterm>File Store</glossterm> folder from RR service working directory to a safe place. 
			</para>
			<sect4>
			<title>Indexing</title>
			<para>To improve performance, all dataset's <glossterm>tags</glossterm> marked as part of 
			primary key are indexed internally.</para>
			</sect4>
		</sect3>
		
		<sect3>
			<title>Hibernate</title>
			<para>
			As said before, all the access to RR database is mediated by Hibernate framework.
			RR always opens one "manager" Hibernate session to access <glossterm>dataset</glossterm> 
			and <glossterm>trigger</glossterm> metadata. For every dataset a new Hibernate session 
			is opened. This guarantees isolation of datasets and prevents 
			need of changing Hibernate session's configuration every time 
			new <glossterm>dataset</glossterm> is added.   
			</para>
		</sect3>
		
		<sect3>
			<title>Entity Classes Assembling</title>
			<para>
			Because datasets are table-like structures and every dataset's 
			schema is fully customizable, we needed to make Hibernate 
			work with dynamically defined entities. Although Hibernate
			has some support for dynamic entities, this support is 
			still experimental. We wanted to make BEEN as stable 
			as possible, so we chose the way of dynamically creating 
			entity classes by OW2 ASM framework. This is how it works:  
			</para>
			<orderedlist>
			<listitem><para>New <glossterm>dataset</glossterm> creation is requested and <glossterm>dataset descriptor</glossterm> is given.</para></listitem>
			<listitem><para>Based on <glossterm>dataset descriptor</glossterm> (giving <glossterm>tag</glossterm> names and types) a new Hibernate entity class
			with all needed persistence annotations is created.</para></listitem>
			<listitem><para>Newly created class is loaded by <glossterm>Result Repository</glossterm>'s private class-loader.</para></listitem>
			<listitem><para>New Hibernate session is created for the new <glossterm>dataset</glossterm> using the entity class just created.</para></listitem>			
			</orderedlist>
		</sect3>
		
	</sect2>
	
	<!-- <sect2>
		<title>Design goals and intentions</title>
		<para>
		The component is designed this weird way because [ingenious idea XYZ] was born in mind...
		</para>
	</sect2> -->
</sect1>