<?xml version="1.0" encoding="UTF-8"?>

<sect1
	xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	xmlns:xml="http://www.w3.org/XML/1998/namespace"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xsi:schemaLocation="http://docbook.org/ns/docbook ../../../docbook-5.0/xsd/docbook.xsd"
>
	<title>Pluggable Module Basics</title>
	
	<sect2>
		<title>What's The Use of Pluggable Modules</title>
		<para>
		Shortly, <glossterm>pluggable modules</glossterm> is a technology that makes BEEN more and easily extendable by offering
		a possibility to define a component with well-defined interface and let it be loaded on demand by 
		BEEN framework. It allows users to write code that can be shared across all BEEN without a 
		need to link this code inside BEEN's core.
		</para>
		<para>
		Pluggable module framework is designed in a way so that you need don't have to 
		understand BEEN internals to create your own <glossterm>pluggable module</glossterm>. You also don't need to rebuild all 
		the BEEN core once you need to create a new <glossterm>pluggable module</glossterm>. 
		</para>
		<para>
		This is a list of main goals that are achieved by introducing <glossterm>pluggable module</glossterm> framework:
		<itemizedlist>
			<listitem><para>Let users to share code among tasks easily.</para></listitem>
			<listitem><para>Prevent unnecessary code to be included in BEEN core.</para></listitem>
			<listitem><para>Allow tasks to load costly resources on demand.</para></listitem>
		</itemizedlist>
		</para>
	</sect2>
	
	<sect2 xml:id="been.devel.pluggable.basics.whatis">
		<title>What Is a Pluggable Module</title>
		<para>
		You can think of a <glossterm>pluggable module</glossterm> as just a plugin for a task. Every <glossterm>pluggable
		module</glossterm> consists of a BEEN package (.bpk zipped file) with a predefined structure.
		
		<glossterm>Pluggable module</glossterm>'s package can contain this:
		<itemizedlist>
			<listitem><para>Package metadata file metadata.xml (mandatory)</para></listitem>
			<listitem><para>Pluggable module configuration file config.xml (mandatory)</para></listitem>
			<listitem><para>JARs containing pluggable module's class files and used libraries (recommended) </para></listitem>
			<listitem><para>Arbitrary resource files used by the pluggable module</para></listitem>
		</itemizedlist>
		</para>
		
				
		<sect3>
		<title>Pluggable Module Package Metadata</title>
		<para>
		Like every valid BEEN package, a <glossterm>pluggable module</glossterm> package contains the metadata 
		file. In order for package to become a <glossterm>pluggable module</glossterm>, metadata has to specify
		the right type of package (it has to have type of "module"). 
		</para>
		<para>
		For a <glossterm>pluggable module</glossterm> pay attention to <code>name</code>, <code>version</code> and <code>providedInterfaces</code>
		tags in metadata files. <glossterm baseform="pluggable module">Pluggable modules</glossterm> are identified by tuple <code>(name, version)</code>. 
		<glossterm>Software Repository</glossterm> also offers a functionality to search <glossterm>pluggable modules</glossterm> 
		by fully-classified name of interface they implement. In this case, <code>providedInterfaces</code> 
		is what gets searched through. Search by provided interface feature is used for example in
		<glossterm>Benchmark Manager</glossterm>, that detects generator and evaluator pluggable modules in this way.  
		</para>
		</sect3>
		
		<sect3>
		<title>Pluggable Module Configuration</title>
		<para>
		Every <glossterm>pluggable module</glossterm> has its configuration file stored in package's root
		and named config.xml. Content of this file is similar to task configuration 
		file, but the format is a little bit different (it's because <glossterm baseform="task">tasks</glossterm> use
		legacy config.xml file coming from older releases of BEEN). In general,
		<glossterm>pluggable module</glossterm> configuration file lets you specify three things:
		Pluggable module's main class (the class that will be instantiated when module 
		is loaded), Pluggable module's classpath (classes that need to be visible to 
		pluggable module when running) and pluggable module dependencies. Every
		<glossterm>pluggable module</glossterm> can have arbitrary number of dependencies. These dependencies 
		are looked after by <glossterm>Pluggable Module Manager</glossterm>.
		</para>
		</sect3>
		
		<sect3>
		<title>JARs and Other Resources in Pluggable Module's Package</title>
		<para>
		<glossterm>Pluggable module</glossterm>'s package can contains JARs and other resources. 
		Usually the package contains one main JAR containing the classes of pluggable module
		itself and JARs with libraries that are used by <glossterm>pluggable module</glossterm>. All these
		JARs need to be referenced in pluggable module's configuration in order 
		to be visible. Resources packed in <glossterm>pluggable module</glossterm> package can be accessed 
		in task's pluggable module directory (this is where pluggable module manager unpacks
		pluggable module package once loaded by a running task).
		</para>  
		<para>
		Note that every pluggable module's classes are by convention divided into
		external classes (classes visible to the <glossterm>task</glossterm> that is using a <glossterm>pluggable module</glossterm>)
		and internal classes (<glossterm>pluggable module</glossterm> implementation classes that is only important 
		for <glossterm>pluggable module</glossterm> itself). For more details on this please see 
		<xref linkend="been.devel.pluggable.components.internals"/> and <xref linkend="been.devel.pluggable.extension"/>.  
		</para>
		</sect3>
	</sect2>	
	
	<sect2>
		<title>Basic Usage</title>
		<para>
		The idea of how to use a <glossterm>pluggable module</glossterm> is simple - once you need to use some functionality that is offered to you by
		some of the pluggable modules in <glossterm>Software Repository</glossterm>, you simply
		ask <glossterm>Pluggable Module Manager</glossterm> to give you and instance of a <glossterm>pluggable module</glossterm> 
		identified by its name and version. What you obtain is an object conforming
		to interface of the <glossterm>pluggable module</glossterm> you asked for.
		</para>	
		<para>
		How to create your own <glossterm>pluggable module</glossterm> will be discussed later.
		</para>	
	</sect2>
	
	<sect2>
		<title>Framework Integration</title>
		<para>
		Pluggable modules are currently utilized in these core BEEN modules:
		<itemizedlist>
			<listitem><para><glossterm>Benchmark Manager</glossterm> evaluators and generators are all pluggable modules.</para></listitem>
			<listitem><para><glossterm>Benchmark Manager</glossterm> uses Derby and Hibernate pluggable module to store <glossterm>analysis</glossterm> details.</para></listitem>
			<listitem><para><glossterm>Results Repository</glossterm> uses Derby and Hibernate pluggable module to store <glossterm>dataset</glossterm> data and metadata.</para></listitem>
		</itemizedlist>
		</para>
	</sect2>
	
	<!--<sect2>
		<title>Classification, design patterns</title>
		<itemizedlist>
			<listitem><para>Is it a Job, a Service or something standalone?</para></listitem>
			<listitem>
				<para>Does it implement anything interesting? (Mediator? Facade?)</para>
			</listitem>
		</itemizedlist>
	</sect2>-->
</sect1>