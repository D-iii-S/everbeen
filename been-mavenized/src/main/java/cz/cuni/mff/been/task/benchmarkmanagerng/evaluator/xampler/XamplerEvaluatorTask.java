/*
 *  BEEN: Benchmarking Environment
 *  ==============================
 *
 *  File author: Jan Tattermusch
 *
 *  GNU Lesser General Public License Version 2.1
 *  ---------------------------------------------
 *  Copyright (C) 2004-2006 Distributed Systems Research Group,
 *  Faculty of Mathematics and Physics, Charles University in Prague
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License version 2.1, as published by the Free Software Foundation.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 *  MA  02111-1307  USA
 */
package cz.cuni.mff.been.task.benchmarkmanagerng.evaluator.xampler;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URL;
import java.rmi.RemoteException;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import cz.cuni.mff.been.common.anttasks.AntTaskException;
import cz.cuni.mff.been.common.anttasks.BZip2;
import cz.cuni.mff.been.common.anttasks.Delete;
import cz.cuni.mff.been.common.anttasks.Move;
import cz.cuni.mff.been.common.scripting.ScriptException;
import cz.cuni.mff.been.pluggablemodule.PluggableModuleException;
import cz.cuni.mff.been.pluggablemodule.csvfiles.CSVFilesPluggableModule;
import cz.cuni.mff.been.pluggablemodule.csvfiles.ResultRepositoryCSVUtils;
import cz.cuni.mff.been.pluggablemodule.rscripting.RScriptingPluggableModule;
import cz.cuni.mff.been.resultsrepositoryng.condition.Condition;
import cz.cuni.mff.been.resultsrepositoryng.condition.Restrictions;
import cz.cuni.mff.been.resultsrepositoryng.data.DataHandleException;
import cz.cuni.mff.been.resultsrepositoryng.data.DataHandleTuple;
import cz.cuni.mff.been.resultsrepositoryng.data.utils.GroupBy;
import cz.cuni.mff.been.task.Task;
import cz.cuni.mff.been.task.TaskException;
import cz.cuni.mff.been.task.TaskInitializationException;
import cz.cuni.mff.been.task.benchmarkmanagerng.evaluator.EvaluatorTask;
import cz.cuni.mff.been.task.benchmarkmanagerng.evaluator.fileexport.Properties;

/**
 * Xampler evaluator task evaluates data that come from tasks
 * generated by Xampler generator. 
 * Results are statistically analyzed and results are output
 * to a directory that conforms Regression Benchmarking Web
 * specification (RBW is a tool for presenting benchmark
 * results on web). 
 * 
 * @author Jan Tattermusch
 *
 */
public class XamplerEvaluatorTask extends EvaluatorTask {
	
	/** name of omniorb timestamp field */
    private static final String OMNIORB_TIMESTAMP_FIELD_NAME = "omniorb_timestamp";
    
    /** name of xampler revision field */
    private static final String XAMPLER_REVISION_FIELD_NAME = "xampler_revision";
    
    /**
     * name of build number field
     */
    private static final String BUILD_NUMBER_FIELD_NAME = "build_number";
    
    /**
     * name of run number field
     */
    private static final String RUN_NUMBER_FIELD_NAME = "run_number";
    
    /**
     * name of suite name field
     */
    private static final String SUITE_FIELD_NAME = "suite_name";
    
    /** dataset's field for storing file id */
    private static final String FILE_ID_FIELD_NAME = "fileid";
	
    
    /** destination directory property name **/
    private static final String PROPERTY_DEST_DIR = "dest.dir";
    
    /** suite property name **/
    private static final String PROPERTY_SUITE_NAME = "suite.name";
    
    /** benchmark property name*/
    private static final String PROPERTY_BENCHMARK_NAME = "benchmark.name";
    
    /** platform property name */
    private static final String PROPERTY_PLATFORM_NAME = "platform.name";
    
    /** process old data property name */
    private static final String PROPERTY_PROCESS_OLD_DATA = "process.old.data";
    
    
    /** parser url to trigger without timestamp */
    private static final String PROPERTY_SITE_URL = "site.url";
    
    /** parser's dependency id */
    private static final String PROPERTY_DEPENDENCY_ID = "dependency.id";
    
    
    /** name of result file */
    private static final String RESULT_FILE_NAME = "result";

    /** CSV files pluggable module */
	private CSVFilesPluggableModule csvFilesModule;

	/** R scripting pluggable module */
	private RScriptingPluggableModule RScriptingModule;
	
	/** separator char for CSV files */
	private static final char SEPARATOR_CHAR = ';';
	
	/** quote char for CSV files */
	private static final char QUOTE_CHAR = '"';
	
	/** destination directory where to export xampler results */
	private String destDir;
	
	/** name of benchmark */
	private String benchmarkName;
	
	/** name of platform */
	private String platformName;
	
	/**  name of suite to evaluate */
	private String suiteName;
	
	/**
	 * evaluation directory
	 */
	private File evalDir = new File(getWorkingDirectory(), "evaluation");

	/**
	 * site URL to get when evaluation is finished
	 */
	private String siteUrl;

	/**
	 * dependency id parameter of RBW 
	 */
	private Object dependencyId;

	/**
	 * if true, all data will be evaluated (even the ones evaluated before)
	 */
	private boolean processOldData;
	
	/**
	 * @throws TaskInitializationException
	 */
	public XamplerEvaluatorTask() throws TaskInitializationException {
		super();
	}


	/* (non-Javadoc)
	 * @see cz.cuni.mff.been.task.benchmarkmanagerng.evaluator.EvaluatorTask#doCheckRequiredProperties()
	 */
	@Override
	protected void doCheckRequiredProperties() throws TaskException {
			
		destDir = getTaskProperty(PROPERTY_DEST_DIR);
		if (destDir == null) {
			throw new TaskException("Property " + PROPERTY_DEST_DIR + " not set.");
		}
		
		benchmarkName = getTaskProperty(PROPERTY_BENCHMARK_NAME);
		if (benchmarkName == null) {
			throw new TaskException("Property " + PROPERTY_BENCHMARK_NAME + " not set.");
		}
		
		platformName = getTaskProperty(PROPERTY_PLATFORM_NAME);
		if (platformName == null) {
			throw new TaskException("Property " + PROPERTY_PLATFORM_NAME + " not set.");
		}
		
		suiteName = getTaskProperty(PROPERTY_SUITE_NAME);
		if (suiteName == null) {
			throw new TaskException("Property " + PROPERTY_SUITE_NAME + " not set.");
		}
		
		siteUrl = getTaskProperty(PROPERTY_SITE_URL);
		if (siteUrl == null) {
			throw new TaskException("Property " + PROPERTY_SITE_URL + " not set.");
		}
		
		dependencyId = getTaskProperty(PROPERTY_DEPENDENCY_ID);
		if (dependencyId == null) {
			throw new TaskException("Property " + PROPERTY_DEPENDENCY_ID + " not set.");
		}
		
		processOldData = getBooleanTaskProperty(PROPERTY_PROCESS_OLD_DATA);
	}

	/** 
	 * 
	 * Runs the evaluator task.
	 * 
	 * @see cz.cuni.mff.been.task.Job#run()
	 */
	@Override
	protected void doRun() throws TaskException {
		
		loadPluggableModules();
		
		List<DataHandleTuple> data;
		
		if (!processOldData) {
			data = loadNewData(Restrictions.eq( SUITE_FIELD_NAME, suiteName));
			logInfo(data.size() + " new rows found for suite \""+ suiteName + "\"");
		} else {
			logInfo("Evaluator task will also process old data");
			data = loadData(
					Restrictions.eq( SUITE_FIELD_NAME, suiteName), getLastSerialProcessed()+1, null);
			logInfo(data.size() + " rows found for suite \""+ suiteName + "\"");
		}
	
		
		
		long lowestDataSerial = getLastSerialProcessed();
		
		/* get highest serial number in data */
		long highestDataSerial = 0;
		for (DataHandleTuple tuple : data) {
			if( tuple.getSerial() > highestDataSerial ){
				highestDataSerial = tuple.getSerial();
			}
		}
		
		Set<String> updatedVersions = new HashSet<String>();
		for(DataHandleTuple row : data) {
			String version;
			try {
				version = row.get(OMNIORB_TIMESTAMP_FIELD_NAME).getValue(String.class);
			} catch (DataHandleException e) {
				throw new TaskException();
			}
			updatedVersions.add(version);
		} 
		
		for(String version : updatedVersions) {
			Condition c = Restrictions.conjunction().
			add(Restrictions.eq(OMNIORB_TIMESTAMP_FIELD_NAME, version)).
			add(Restrictions.eq( SUITE_FIELD_NAME, suiteName)).
			add(Restrictions.isNotNull(FILE_ID_FIELD_NAME));
			
			List<DataHandleTuple> currentVersionData = loadData(c, lowestDataSerial, highestDataSerial);
			
			GroupBy versionGroups = new GroupBy(currentVersionData,
						new String[] {XAMPLER_REVISION_FIELD_NAME,
						OMNIORB_TIMESTAMP_FIELD_NAME,
						SUITE_FIELD_NAME});
						
			for (DataHandleTuple versionKey : versionGroups.groups()) {
				Collection<DataHandleTuple> versionGroup = versionGroups.getGroup(versionKey);
				
				logInfo("Evaluating results for version: " + versionKey.toString());
				
				File versionDir = getVersionDestDir(versionKey);
				evaluateVersion(versionGroup, versionDir);
				
				String url = getParserUrl(version);
				notifyParser(url);
			}
		}
		
		purgeDir(evalDir);
		//TODO : notify drupal plugin parser 
		
		if( getTaskProperty(Properties.TRIGGER_ID) != null ){
			notifyDataProcessed(highestDataSerial);
		}
	}
	
	
	/**
	 * Evaluates data for one version.
	 * 
	 * @param groupData xampler results rows for version to evaluate
	 * @param versionDir directory to use when evaluating 
	 * @throws TaskException
	 */
	private void evaluateVersion(Collection<DataHandleTuple> groupData, File versionDir) throws TaskException {
		try {
			purgeDir(evalDir);
			evalDir.mkdirs();

			dumpResultsData(groupData, true);

			
			File resultFile = calculateStatistics(evalDir);
			Move.moveToDir(resultFile.getAbsolutePath(), versionDir.getAbsolutePath());
			logInfo("Version statistics calculated and deployed");

			GroupBy buildGroups = new GroupBy(groupData, 
					new String[] {XAMPLER_REVISION_FIELD_NAME,
					OMNIORB_TIMESTAMP_FIELD_NAME,
					SUITE_FIELD_NAME,
					BUILD_NUMBER_FIELD_NAME});

			for (DataHandleTuple buildKey : buildGroups.groups()) {
				Collection<DataHandleTuple> buildGroup = buildGroups.getGroup(buildKey);

				logInfo("Evaluating results for build: " + buildKey.toString());

				Integer buildNumber = buildKey.get(BUILD_NUMBER_FIELD_NAME).getValue(Integer.class);

				File buildDir = new File(versionDir, buildNumber.toString());
				evaluateBuild(buildGroup, buildDir);
			}
			
		
		} catch (AntTaskException e) {
			e.printStackTrace();
			throw new TaskException("Error evaluating version data", e);
		} catch (DataHandleException e) {
			e.printStackTrace();
			throw new TaskException("Error evaluating version data", e);
		}
	}

	/**
	 * Evaluates one build
	 * @param groupData data of build group
	 * @param buildDir build directory
	 * @throws TaskException
	 */
	private void evaluateBuild(Collection<DataHandleTuple> groupData, File buildDir) throws TaskException {
		try {
			buildDir.mkdirs();
			
			dumpResultsData(groupData, false);	// we dont have to download files, they're already downloaded by evaluateVersion
			File resultFile = calculateStatistics(evalDir);
			Move.moveToDir(resultFile.getAbsolutePath(), buildDir.getAbsolutePath());
			logInfo("Build statistics calculated and deployed");
			
			for (DataHandleTuple row : groupData) {
				Integer runNumber = row.get(RUN_NUMBER_FIELD_NAME).getValue(Integer.class);

				UUID fileId = row.get(FILE_ID_FIELD_NAME).getValue(UUID.class);
				File dataFile = createCsvUtil().getFileLocation(fileId);

				/* move result file */
				File destArchive = new File(buildDir, runNumber.toString() + ".bz2");
				
				BZip2.bzip(dataFile.getAbsolutePath(), destArchive.getAbsolutePath());
				dataFile.delete();
				
				logInfo("Run "+ runNumber+" result file deployed");
			}			
			
		} catch (DataHandleException e) {
			throw new TaskException("Error evaluating build data.", e);
		} catch (AntTaskException e) {
			throw new TaskException("Error evaluating build data.", e);
		}
	}


	/**
	 * Loads pluggable modules needed by this task
	 * @throws TaskException
	 */
	private void loadPluggableModules() throws TaskException {
		logInfo("Loading pluggable modules...");
		
		try {
			csvFilesModule = Task.getTaskHandle().getPluggableModule(
					CSVFilesPluggableModule.class, "csvfiles", "1.0");
			
			RScriptingModule = Task.getTaskHandle().getPluggableModule(
					RScriptingPluggableModule.class, "rscripting", "1.0");
			
		} catch (PluggableModuleException e) {
			throw new TaskException("Error loading pluggable module", e);
		} 	
	}
	
	/**
	 * Purges given directory 
	 * @param dir directory to purge
	 * @throws TaskException
	 */
	private void purgeDir(File dir) throws TaskException {
		try {
			if (dir.exists()) {
				Delete.deleteDirectory(dir.getAbsolutePath());
			}
		} catch (AntTaskException e1) {
			throw new TaskException("Error purging directory \"" + dir.getAbsolutePath()+ "\"");
		}
	}
	
	/**
	 * Dumps results data to CSV file.
	 * 
	 * @param data data to dump
	 * @param downloadFiles true if files referenced by file data handles should be downloaded first 
	 * @throws TaskException
	 */
	private void dumpResultsData(Collection<DataHandleTuple> data, boolean downloadFiles) throws TaskException {	
		File csvFile = new File(evalDir, "input.csv");
		ResultRepositoryCSVUtils csv;			
		try {
			csv = createCsvUtil();
			csv.writeCSVFile(csvFile, new String[] {
						XAMPLER_REVISION_FIELD_NAME,
						OMNIORB_TIMESTAMP_FIELD_NAME,
						SUITE_FIELD_NAME,
						BUILD_NUMBER_FIELD_NAME,
						RUN_NUMBER_FIELD_NAME,
						FILE_ID_FIELD_NAME }, data, downloadFiles);
		} catch (RemoteException e) {
			throw new TaskException("Error writing CSV file", e);
		} catch (IOException e) {
			throw new TaskException("Error writing CSV file", e);
		}
		
	}

	/**
	 * Launches R to calculate statistics about build or version. 
	 * @param homeDir home directory (where to look for input files and where to output the results).
	 * @return file with results
	 * @throws TaskException
	 */
	private File calculateStatistics(File homeDir) throws TaskException {
		File scriptFile = new File(getTaskDirectory(), "stats.R");
		File routFile = new File(homeDir, "stats.Rout");
		try {
			int result = RScriptingModule.runRScript(scriptFile, homeDir.getAbsolutePath());
			if (result != 0) {
				throw new TaskException("R script execution resulted in an error. Check " + routFile.getAbsolutePath() + " to see details.");
			}
		} catch (ScriptException e) {
			throw new TaskException("Error running evaluation R script.", e);
		}
		
		return new File(homeDir, RESULT_FILE_NAME);
	}
	
	/**
	 * Generates name of version destination directory (conforming to RBW specification)
	 * 
	 * @param key version group key describing the version we are currently processing.
	 * @return directory where evaluator should export version data
	 * @throws TaskException
	 */
	private File getVersionDestDir(DataHandleTuple key) throws TaskException {
		try {
			String version = key.get(OMNIORB_TIMESTAMP_FIELD_NAME).getValue(String.class);
			String timestampString = formatTimestamp(version);
			
			String path = destDir + File.separator + timestampString + File.separator + benchmarkName + File.separator + platformName; 
			
			return new File(path);
		} catch(DataHandleException e) {
			throw new TaskException("Error getting version directory.");
		}
	}
	
	/**
	 * Constructs RBW parser's URL (used to notify RBW that new version data are available)
	 * @param version version that will be messaged to the parser
	 * @return parser's URL
	 */
	private String getParserUrl(String version) {
		return siteUrl + "?q=parser/" + dependencyId + "/" + formatTimestamp(version);
	}
	
	/**
	 * Formats timestamp in format accepted by RBW parser.
	 * @param version version timestamp in format "YYYY-MM-DD HH:mm:ss" 
	 * @return timestamp in format "YYYYMMDD-HHmmss"
	 */
	private String formatTimestamp(String version) {
		return version.replaceAll("-", "").replaceAll(":", "").replaceAll(" ", "-");
	}
	
	/**
	 * Factory method for creating CSV utils.
	 * @return CSVUtils instance
	 * @throws TaskException
	 */
	private ResultRepositoryCSVUtils createCsvUtil() throws TaskException {
		try {
			return csvFilesModule.createResultsRepositoryCSVUtils(getResultsRepository().getFileStoreClient(), evalDir, SEPARATOR_CHAR, QUOTE_CHAR);
		} catch (RemoteException e) {
			throw new TaskException("Error getting RR filestore client.", e);
		}
	}
	
	/**
	 * Notifies RBW parser about new version.
	 * @param url parser URL.
	 * @throws TaskException
	 */
	private void notifyParser(String url) throws TaskException {
		BufferedReader r = null;
		try {
			logInfo("Notifying parser on " + url + ".");
			URL parserUrl = new URL(url);
			r = new BufferedReader(new InputStreamReader(parserUrl.openStream()));

			String line = r.readLine();
			logInfo("Parser replied: " + line);
			if (!"Parsing was succesfully finished.".equals(line)) {
				throw new TaskException("Invalid response from the parser.");
			}
			r.close();
			logInfo("Parser succesfully notified about new version.");
		} catch(IOException e) {
			throw new TaskException("Error notifying the parser.", e);
		}
	}
}
