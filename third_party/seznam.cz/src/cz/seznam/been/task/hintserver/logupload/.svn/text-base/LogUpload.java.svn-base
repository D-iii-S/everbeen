/*
 *  BEEN: Benchmarking Environment
 *  ==============================
 *
 *  File author: Jiri Tauber
 *
 *  GNU Lesser General Public License Version 2.1
 *  ---------------------------------------------
 *  Copyright (C) 2004-2010 Distributed Systems Research Group,
 *  Faculty of Mathematics and Physics, Charles University in Prague
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License version 2.1, as published by the Free Software Foundation.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 *  MA  02111-1307  USA
 */
package cz.seznam.been.task.hintserver.logupload;

import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.rmi.RemoteException;
import java.util.HashMap;
import java.util.List;
import java.util.UUID;

import cz.cuni.mff.been.pluggablemodule.PluggableModuleException;
import cz.cuni.mff.been.pluggablemodule.fileagent.FileAgent;
import cz.cuni.mff.been.resultsrepositoryng.RRDataInterface;
import cz.cuni.mff.been.resultsrepositoryng.ResultsRepositoryException;
import cz.cuni.mff.been.resultsrepositoryng.condition.Condition;
import cz.cuni.mff.been.resultsrepositoryng.condition.Restrictions;
import cz.cuni.mff.been.resultsrepositoryng.data.DataHandleTuple;
import cz.cuni.mff.been.task.TaskException;
import cz.cuni.mff.been.task.TaskInitializationException;
import cz.seznam.been.task.common.FileAgentTask;

/**
 * Task class that takes log generated by the tested hint server and uploads
 * it to the Results Repository.
 * 
 * @author Jiri Tauber
 */
public class LogUpload extends FileAgentTask {

	//-----------------------------------------------------------------------//
	// Task property names:
	/** Name of the property holding path to the log file */
	public static String PROP_LOG_FILENAME = "log.filename";
	/** The name of the property which tells the analysis name */
	public static final String PROP_ANALYSIS = "analysis";
	/** Name of the property holding id of the server binary used */
	public static String PROP_BINARY = "binary";
	/** Name of the property holding number of clients participating */
	public static String PROP_CLIENT_COUNT = "client.count";
	/** The name of the property which has the RPS sequence used in generating the load */
	public static final String PROP_RPS_SEQUENCE = "rps.sequence";

	//-----------------------------------------------------------------------//
	// Following section has a copy in HinserverGenerator
	/** The name of the dataset where logs are stored */
	private static final String DATASET_LOG = "server_log";
	/** A log dataset tag */
	public static final String TAG_LOG_LOGFILE = "log_file";
	/** A log dataset tag */
	public static final String TAG_LOG_BINARY = "binary_id";
	/** A log dataset tag */
	public static final String TAG_LOG_RPS_SEQUENCE = "rps_sequence";
	/** A log dataset tag */
	public static final String TAG_LOG_CLIENT_COUNT = "client_count";
	/** A log dataset tag */
	public static final String TAG_LOG_SERVER = "server";
	/** A log dataset tag */
	public static final String TAG_LOG_DATABASE = "database";

	/** The name of the dateset where compiled binaries are stored */
	public static final String DATASET_BINARY = "binary";
	/** A binary dataset tag */
	public static final String TAG_BINARY_BINARY = "bin_file";
	/** A binary dataset tag */
	public static final String TAG_BINARY_RUN_COUNT = "run_count";

	//-----------------------------------------------------------------------//

	public LogUpload() throws TaskInitializationException {
		super();
	}


	/* (non-Javadoc)
	 * @see cz.cuni.mff.been.task.Job#checkRequiredProperties()
	 */
	@Override
	protected void checkRequiredProperties() throws TaskException {
		StringBuilder err = new StringBuilder();
		String propName;
		String propValue;

		propName = PROP_ANALYSIS;
		propValue = getTaskProperty(propName); 
		if (propValue == null || propValue.isEmpty()) {
			err.append("Property "+propName+" is missing;");
		}

		propName = PROP_BINARY;
		propValue = getTaskProperty(propName); 
		if (propValue == null || propValue.isEmpty()) {
			err.append("Property "+propName+" is missing;");
		} else {
			try {
				UUID.fromString(propValue);
			} catch (IllegalArgumentException e) {
				err.append("Property "+propName+" is not an UUID;");
			}
		}

		propName = PROP_LOG_FILENAME;
		propValue = getTaskProperty(propName); 
		if (propValue == null || propValue.isEmpty()) {
			err.append("Property "+propName+" is missing;");
		} else {
			File file = new File(propValue);
			if (!file.exists()) {
				err.append("File "+propValue+" is missing;");
			} else if (!file.canRead()) {
				err.append("File "+propValue+" can not be read;");
			}
		}

		propName = PROP_CLIENT_COUNT;
		propValue = getTaskProperty(propName); 
		if (propValue == null || propValue.isEmpty()) {
			err.append("Property "+propName+" is missing;");
		} else {
			if (!propValue.matches("^\\d+$")) {
				err.append("Property "+propName+" is not an integer;");
			}
		}

		propName = PROP_RPS_SEQUENCE;
		propValue = getTaskProperty(propName); 
		if (propValue == null || propValue.isEmpty()) {
			err.append("Property "+propName+" is missing;");
		} else if (!propValue.matches("^\\d+([,; ]\\d+)*$")) {
			err.append("Property "+propName+" is not an integer;");
		}

		if (err.length() > 0) {
			throw new TaskException(err.toString());
		}
	}

	
	/* (non-Javadoc)
	 * @see cz.cuni.mff.been.task.Job#run()
	 */
	@Override
	protected void run() throws TaskException {
		File file = new File(getTaskProperty(PROP_LOG_FILENAME));
		String analysisName = getTaskProperty(PROP_ANALYSIS); 

		// Load the run count for the binary that has just stopped
		RRDataInterface rr;
		DataHandleTuple binaryTuple;
		Condition binaryCondition = Restrictions.eq(TAG_BINARY_BINARY, getTaskPropertyObject(PROP_BINARY));
		try {
			rr = getRRInterface();
			List<DataHandleTuple> data = rr.loadData(
						analysisName,
						DATASET_BINARY,
						binaryCondition,
						0L, Long.MAX_VALUE);
			if (data.size() != 1) {
				throw new TaskException("Results Repository returned " + data.size()
						+ " results when searching for specified binary entry");
			}
			binaryTuple = data.get(0);
			int runCount = binaryTuple.get(TAG_BINARY_RUN_COUNT).getValue(Integer.class);
			binaryTuple.set(TAG_BINARY_RUN_COUNT, runCount + 1);
		} catch (RemoteException e) {
			throw new TaskException("Error loading Results Repository refference", e);
		} catch (ResultsRepositoryException e) {
			throw new TaskException("Error loading binary data from the Results Repository", e);
		}

		// Create the tag values for the log file
		HashMap<String, Serializable> tags = new HashMap<String, Serializable>();
		tags.put(TAG_LOG_CLIENT_COUNT, getTaskProperty(PROP_CLIENT_COUNT));
		tags.put(TAG_LOG_BINARY, getTaskProperty(PROP_BINARY));
		tags.put(TAG_LOG_RPS_SEQUENCE, getTaskProperty(PROP_RPS_SEQUENCE));

		tags.put(TAG_LOG_SERVER, getServerInfo());
		tags.put(TAG_LOG_DATABASE, getDBVersion());

		try {
			FileAgent agent = getFileAgent().createRRFileAgent(
					analysisName,
					DATASET_LOG,
					TAG_LOG_LOGFILE);
			// save the log file
			agent.storeFile(file, tags);
			// update the run count for this binary
			rr.saveData(analysisName, DATASET_BINARY, binaryTuple);
		} catch (PluggableModuleException e) {
			throw new TaskException("Error creating File Agent", e);
		} catch (IOException e) {
			throw new TaskException(e);
		} catch (ResultsRepositoryException e) {
			throw new TaskException("Error updating run count for the current binary", e);
		}
	}


	//-----------------------------------------------------------------------//
	/**
	 * Finds out detiled information about the server machine
	 * @return String holding server machine information
	 */
	private String getServerInfo() {
		// TODO: Find out from Host Manager?
		return "unknown";
	}


	/**
	 * Determines version of the HintServer database
	 * @return The database version
	 */
	private String getDBVersion() {
		// TODO
		return "unknown";
	}

}
