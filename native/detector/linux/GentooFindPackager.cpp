/*
 *  BEEN: Benchmarking Environment
 *  ==============================
 *
 *  File author: Branislav Repcek
 *
 *  GNU Lesser General Public License Version 2.1
 *  ---------------------------------------------
 *  Copyright (C) 2004-2006 Distributed Systems Research Group,
 *  Faculty of Mathematics and Physics, Charles University in Prague
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License version 2.1, as published by the Free Software Foundation.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 *  MA  02111-1307  USA
 */

/*! \file GentooFindPackager.cpp
 *  \author Branislav Repcek
 *  \date 16. 12. 2006
 *
 *  \brief Fake packager that uses find.
 */

#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "../common/UnicodeString.h"
#include "../common/MessageReporter.h"
#include "../common/Product.h"
#include "GentooFindPackager.h"
#include "ForkAndPipe.h"
#include "SystemHelper.h"
#include "FileParser.h"

using namespace std;

namespace hwdet
{
    /*! \param parent_reporter Message reporter which will receive all messages generated
     *         by this class.
     */
    GentooFindPackager::GentooFindPackager(MessageReporter *parent_reporter) :
    Packager(TXT("GentooFindPackager"), parent_reporter),
    is_supported(false)
    {
        is_supported = FileTestPermissions("/usr/bin/find", PERMISSIONS_EXECUTE);
    }
        
    /*!
     */
    GentooFindPackager::~GentooFindPackager(void)
    {
    }

    /*! Test if find is supported on the system (this should always be true, since find
     *  is pretty basic command).
     * 
     *  \return true if find is supported, false otherwise.
     */
    bool GentooFindPackager::IsSupported(void)
    {
        return is_supported;
    }
    
    /*! This will find all files in the emerge database.
     * 
     *  \param products XML node which will receive parsed data.
     * 
     *  \return true on success, false otherwise.
     */
    bool GentooFindPackager::DetectSoftware(XMLElement *products)
    {
        if (!is_supported || !products)
        {
            return false;
        }
        
        ReportMessage(TXT("Detecting installed software."));
        
        FindExec find_exec(this, products);
        
        return find_exec.Run();
    }
    
    /*! \param parent_reporter Message reporter which will receive all messages generated in
     *         this class.
     *  \param output XML node which will receive parsed data.
     */
    GentooFindPackager::FindExec::FindExec(MessageReporter *parent_reporter, XMLElement *output) :
    ForkAndPipe(TXT("FindExec"), parent_reporter),
    output_node(output)
    {
    }
    
    /*!
     */
    GentooFindPackager::FindExec::~FindExec(void)
    {
    }
    
    /*! Reads all data generated by the child process.
     * 
     *  \param child_pid PID of the child process.
     *  \param file File created from the output decriptor of the pipe.
     */
    void GentooFindPackager::FindExec::ParentProcess(pid_t child_pid, FILE *file)
    {
        char *buffer = (char *) malloc(1024);
        size_t size = 1024;
        
        String name;
        String vendor(TXT("(unknown)")); // always unknown
        String version;
        
        while (getline(&buffer, &size, file) != -1)
        {
            name = String(buffer);
            
            if (BeginsWith(name, TXT("find:")))
            {
                // Skip this line since it is message from the find command.
                continue;
            }
            
            // Now we have to find version.
            // Typical line looks like this: sys-libs/ncurses-5.4-r6
            // So we will search for the last dash and if it is preceded by the number,
            // we will search again.
            // We cannot start from the first (nor second) dash in the whole name, since
            // some packages have multi-word names and words are separated by dashes.
            // Note that this algorithm is probably not perfect, but it is better than nothing.
            size_t slash = name.find(TXT("/"));
            size_t last_dash = name.find_last_of(TXT("-"));
            
            if ((last_dash < slash) || (last_dash == name.npos))
            {
                // No version info available (last dash is before the slash that separates
                // category from the package name).
                version = TXT("(unknown)");
            }
            else
            {
                size_t version_start = last_dash + 1;
                if (isdigit(name[last_dash - 1]))
                {
                    // search again
                    size_t pre_last_dash = name.find_last_of(TXT("-"), last_dash - 1);
                    
                    if ((pre_last_dash > slash) && (pre_last_dash != name.npos))
                    {
                        version_start = pre_last_dash + 1;
                    }
                }
                
                version = name.substr(version_start);
            }
            
            output_node->AddSubNode(new Product(name, vendor, version));
        }
        
        free(buffer);
    }
    
    /*! This will search for all files in the portage database and print names on the console.
     *  Output format is exactly same as that produced by the equery.
     */
    void GentooFindPackager::FindExec::ChildProcess(void)
    {
        if (execl("/usr/bin/find", "/usr/bin/find", "/var/db/pkg/", "-mindepth", "2", 
            "-maxdepth", "2", "-printf", "%P\n", (char *) NULL) == -1)
        {
            int err_id = GetLastErrorID();
            
            cerr << "Unable to exec find: " << GetErrorName(err_id) << endl;
            exit(-1);
        }
    }
}
