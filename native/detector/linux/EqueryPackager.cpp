/*
 *  BEEN: Benchmarking Environment
 *  ==============================
 *
 *  File author: Branislav Repcek
 *
 *  GNU Lesser General Public License Version 2.1
 *  ---------------------------------------------
 *  Copyright (C) 2004-2006 Distributed Systems Research Group,
 *  Faculty of Mathematics and Physics, Charles University in Prague
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License version 2.1, as published by the Free Software Foundation.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 *  MA  02111-1307  USA
 */

/*! \file EqueryPackager.cpp
 *  \author Branislav Repcek
 *  \date 15. 12. 2006
 *
 *  \brief Equery adapter implementation.
 */

#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include "../common/UnicodeString.h"
#include "../common/MessageReporter.h"
#include "../common/Product.h"
#include "EqueryPackager.h"
#include "ForkAndPipe.h"
#include "SystemHelper.h"

using namespace std;

namespace hwdet
{
    /*! \param parent_reporter Message reporter which will receive all messages generated
     *         by this class.
     */
    EqueryPackager::EqueryPackager(MessageReporter *parent_reporter) :
    Packager(TXT("EqueryPackager"), parent_reporter),
    is_supported(false)
    {
        is_supported = FileTestPermissions("/usr/bin/equery", PERMISSIONS_EXECUTE);
    }

    /*!
     */
    EqueryPackager::~EqueryPackager(void)
    {
    }

    /*! Test if eqeury is supported. equery is supported if /usr/bin/equery file exists 
     *  and current user has permissions to execute that file.
     * 
     *  \return true if equery is supported, false otherwise.
     */
    bool EqueryPackager::IsSupported(void)
    {
        return is_supported;
    }
    
    /*! This will exec equery and parse all data generated by the command.
     * 
     *  \param products XML node which will receive parsed data.
     * 
     *  \return true on success, false otherwise.
     */
    bool EqueryPackager::DetectSoftware(XMLElement *products)
    {
        if (!is_supported || !products)
        {
            return false;
        }
        
        ReportMessage(TXT("Detecting installed software."));
        
        EqueryExec equery_exec(this, products);
        
        return equery_exec.Run();
    }
    
    /*! \param parent_reporter Message reporter which will receive all messages generated in
     *         this class.
     *  \param output XML node which will receive parsed data.
     */
    EqueryPackager::EqueryExec::EqueryExec(MessageReporter *parent_reporter, XMLElement *output) :
    ForkAndPipe(TXT("EqueryExec"), parent_reporter),
    output_node(output)
    {
    }
    
    /*!
     */
    EqueryPackager::EqueryExec::~EqueryExec(void)
    {
    }
    
    /*! Reads all data generated by the child process.
     * 
     *  \param child_pid PID of the child process.
     *  \param file File created from the output decriptor of the pipe.
     */
    void EqueryPackager::EqueryExec::ParentProcess(pid_t child_pid, FILE *file)
    {
        char *buffer = (char *) malloc(1024);
        size_t size = 1024;
        
        String name;
        String vendor(TXT("(unknown)")); // always unknown, since equery does not provide vendor's name
        String version;
        size_t count = 0;
        
        while (getline(&buffer, &size, file) != -1)
        {
            count += 1;
            if (count == 1)
            {
                // Skip first line.
                continue;
            }

            name = String(buffer);
            
            // Now we have to find version.
            // Typical line looks like this: sys-libs/ncurses-5.4-r6
            // So we will search for the last dash and if it is preceded by the number,
            // we will search again.
            // We cannot start from the first (nor second) dash in the whole name, since
            // some packages have multi-word names and words are separated by dashes.
            // Note that this algorithm is probably not perfect, but it is better than nothing.
            size_t slash = name.find(TXT("/"));
            size_t last_dash = name.find_last_of(TXT("-"));
            
            if ((last_dash < slash) || (last_dash == name.npos))
            {
                // No version info available (last dash is before the slash that separates
                // category from the package name).
                version = TXT("(unknown)");
            }
            else
            {
                size_t version_start = last_dash + 1;
                if (isdigit(name[last_dash - 1]))
                {
                    // search again
                    size_t pre_last_dash = name.find_last_of(TXT("-"), last_dash - 1);
                    
                    if ((pre_last_dash > slash) && (pre_last_dash != name.npos))
                    {
                        version_start = pre_last_dash + 1;
                    }
                }
                
                version = name.substr(version_start);
            }
            
            output_node->AddSubNode(new Product(name, vendor, version));
        }
        
        free(buffer);
    }
    
    /*! This will execute equery with command-line options set so that only list of all
     *  installed packages is produced.
     */
    void EqueryPackager::EqueryExec::ChildProcess(void)
    {
        /*  Output format:
         *  For each package one line will be output:
         *    category/package-name-version
         *
         *  well, this format sucks... and it cannot be changed
         */
        
        if (execl("/usr/bin/equery", "/usr/bin/equery", "-C", "list", (char *) NULL) == -1)
        {
            int err_id = GetLastErrorID();
            
            cerr << "Unable to exec equery: " << GetErrorName(err_id) << endl;
            exit(-1);
        }
    }
}
