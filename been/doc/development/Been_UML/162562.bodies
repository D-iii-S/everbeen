class SoftwareAliasDefinition
!!!386434.java!!!	SoftwareAliasDefinition(in aliasName : String, in resultName : String, in resultVendor : String, in resultVersion : String, inout osRestriction : ObjectRestriction, inout appRestriction : ObjectRestriction)
		
		MiscUtils.verifyStringParameterBoth(aliasName, "aliasName");
		MiscUtils.verifyStringParameterBoth(resultName, "resultName");
		MiscUtils.verifyParameterIsNotNull(appRestriction, "appRestriction");
		
		if ((osRestriction != null) && (!osRestriction.getObjectPath().equals(""))) {
			throw new InvalidArgumentException("Object path for OS restriction has to be empty string.");
		}
		
		if (!appRestriction.getObjectPath().equals("")) {
			throw new InvalidArgumentException("Object path in restriction for application"
					+ " is not empty.");
		}
		
		this.aliasName = aliasName;
		this.resultName = resultName;
		this.resultVendor = resultVendor;
		this.resultVersion = resultVersion;
		
		validateDefinitionHeader();
		
		this.osRestriction = osRestriction;
		this.appRestriction = appRestriction;
!!!386562.java!!!	SoftwareAliasDefinition(in aliasName : String, in resultName : String, in resultVendor : String, in resultVersion : String, inout osRestriction : RSLRestriction, inout appRestriction : RSLRestriction)

		MiscUtils.verifyStringParameterBoth(aliasName, "aliasName");
		MiscUtils.verifyStringParameterBoth(resultName, "resultName");
		MiscUtils.verifyParameterIsNotNull(appRestriction, "appRestriction");
	
		this.aliasName = aliasName;
		this.resultName = resultName;
		this.resultVendor = resultVendor;
		this.resultVersion = resultVersion;
		
		validateDefinitionHeader();
		
		this.osRestriction = osRestriction;
		this.appRestriction = appRestriction;
!!!386690.java!!!	SoftwareAliasDefinition(inout node : Node)
		
		parseXMLNode(node);
!!!386818.java!!!	exportAsElement(inout document : Document) : Element
		
		/*
		 * Resulting node:
		 * 
		 * <aliasDefinition alias=<aliasName> name=<resultName> vendor=<resultVendor> 
		 *   version=<resultVersion> >
		 *     <os type="<type>">
		 *       <operating system restriction/>
		 *     </os>
		 *     <app type="<type>">
		 *       <application restriction/>
		 *     </app>
		 * </aliasDefinition>
		 * 
		 * where type is canonical name of the runtime type of the restriction
		 */
		
		Element element = document.createElement(getXMLNodeName());
		
		element.setAttribute("alias", aliasName);
		element.setAttribute("name", resultName);
		
		if (resultVendor != null) {
			element.setAttribute("vendor", resultVendor);
		}
		
		if (resultVersion != null) {
			element.setAttribute("version", resultVersion);
		}
		
		if (osRestriction != null) {
			Element osRestr = document.createElement("os");
			
			element.appendChild(osRestr);
			osRestr.setAttribute("type", osRestriction.getClass().getCanonicalName());
			
			osRestr.appendChild(osRestriction.exportAsElement(document));
		}
		
		Element appRestr = document.createElement("app");
		element.appendChild(appRestr);
		appRestr.setAttribute("type", appRestriction.getClass().getCanonicalName());
		appRestr.appendChild(appRestriction.exportAsElement(document));
		
		return element;
!!!386946.java!!!	getXMLNodeName() : String
		
		return XML_NODE_NAME;
!!!387074.java!!!	parseXMLNode(inout node : Node) : void
		
		aliasName = XMLHelper.getAttributeValueByName("alias", node);
		resultName = XMLHelper.getAttributeValueByName("name", node);
		
		if (XMLHelper.hasAttribute("version", node)) {
			resultVersion = XMLHelper.getAttributeValueByName("version", node);
		} else {
			resultVersion = null;
		}
		
		if (XMLHelper.hasAttribute("vendor", node)) {
			resultVendor = XMLHelper.getAttributeValueByName("vendor", node);
		} else {
			resultVendor = null;
		}
		
		Node osNode = null;
		
		try {
			osNode = XMLHelper.getSubNodeByName("os", node);
		} catch (InputParseException e) {
			// no os node, not an error
			osNode = null;
		}
		
		if (osNode != null) {
			String restrictionType = XMLHelper.getAttributeValueByName("type", osNode);

			// this is kind of stupid, but using Java's reflection here is waaaay too long
			if (restrictionType.equals(RSLRestriction.class.getCanonicalName())) {
				Node n = XMLHelper.getSubNodeByName(RSLRestriction.XML_NODE_NAME, osNode);
				
				osRestriction = new RSLRestriction(n);
			} else if (restrictionType.equals(ObjectRestriction.class.getCanonicalName())) {
				Node n = XMLHelper.getSubNodeByName(ObjectRestriction.XML_NODE_NAME, osNode);
				
				osRestriction = new ObjectRestriction(n);
			} else {
				throw new InputParseException("Unknown restriction type \"" + restrictionType + "\".");
			}
		} else {
			osRestriction = null;
		}
		
		Node appNode = XMLHelper.getSubNodeByName("app", node);
		String restrictionType = XMLHelper.getAttributeValueByName("type", appNode);

		if (restrictionType.equals(RSLRestriction.class.getCanonicalName())) {
			Node n = XMLHelper.getSubNodeByName(RSLRestriction.XML_NODE_NAME, appNode);
			
			appRestriction = new RSLRestriction(n);
		} else if (restrictionType.equals(ObjectRestriction.class.getCanonicalName())) {
			Node n = XMLHelper.getSubNodeByName(ObjectRestriction.XML_NODE_NAME, appNode);
			
			appRestriction = new ObjectRestriction(n);
		} else {
			throw new InputParseException("Unknown restriction type \"" + restrictionType + "\".");
		}
		
		try {
			validateDefinitionHeader();
		} catch (Exception e) {
			throw new InputParseException("Error parsing definition: " + e.getMessage(), e);
		}
!!!387202.java!!!	getAliasName() : String
		return aliasName;
!!!387330.java!!!	setAliasName(in aliasName : String) : void
		this.aliasName = aliasName;
!!!387458.java!!!	getAppRestriction() : RestrictionInterface
		return appRestriction;
!!!387586.java!!!	setAppRestriction(inout appRestriction : ObjectRestriction) : void
		this.appRestriction = appRestriction;
!!!387714.java!!!	getOsRestriction() : RestrictionInterface
		return osRestriction;
!!!387842.java!!!	setOsRestriction(inout osRestriction : ObjectRestriction) : void
		this.osRestriction = osRestriction;
!!!387970.java!!!	getResultName() : String
		return resultName;
!!!388098.java!!!	setResultName(in resultName : String) : void
		this.resultName = resultName;
!!!388226.java!!!	getResultVendor() : String
		return resultVendor;
!!!388354.java!!!	setResultVendor(in resultVendor : String) : void
		this.resultVendor = resultVendor;
!!!388482.java!!!	getResultVersion() : String
		return resultVersion;
!!!388610.java!!!	setResultVersion(in resultVersion : String) : void
		this.resultVersion = resultVersion;
!!!388738.java!!!	hashCode() : int
		
		return resultVersion.hashCode() + 31 * resultName.hashCode() + 967 * resultVendor.hashCode()
		       + 29789 * aliasName.hashCode() + 923467 * osRestriction.hashCode()
		       + 28627493 * appRestriction.hashCode();
!!!388866.java!!!	equals(inout o : Object) : boolean
		
		if (o instanceof SoftwareAliasDefinition) {
			SoftwareAliasDefinition t = (SoftwareAliasDefinition) o;
			
			return aliasName.equals(t.aliasName) && resultVersion.equals(t.resultVersion)
			       && resultVendor.equals(t.resultVendor) && resultName.equals(t.resultName)
			       && osRestriction.equals(t.osRestriction) && appRestriction.equals(t.appRestriction);
		} else {
			return false;
		}
!!!388994.java!!!	toString() : String
		
		return "{" + aliasName + "|" + resultName + ";" + resultVendor + ";" + resultVersion + "}";
!!!389122.java!!!	validateDefinitionHeader() : void
		
		String []allowedNames = new String[] {
				"version",
				"name",
				"vendor"
			};
		
		ValidatingDataProvider provider = new ValidatingDataProvider(allowedNames);
		SubstituteVariableValues substitutor = new SubstituteVariableValues("[\\p{Alpha}_]+");
		
		try {
			substitutor.parseString(aliasName, provider);
		} catch (Exception e) {
			throw new InvalidArgumentException("Invalid alias name in definition: "
					+ e.getMessage(), e);
		}

		try {
			substitutor.parseString(resultName, provider);
		} catch (Exception e) {
			throw new InvalidArgumentException("Invalid result name in alias definition: "
					+ e.getMessage(), e);
		}
	
		try {
			substitutor.parseString(resultVendor, provider);
		} catch (Exception e) {
			throw new InvalidArgumentException("Invalid result vendor in alias definition: "
					+ e.getMessage(), e);
		}
	
		try {
			substitutor.parseString(resultVersion, provider);
		} catch (Exception e) {
			throw new InvalidArgumentException("Invalid result version in alias definition: "
					+ e.getMessage(), e);
		}
