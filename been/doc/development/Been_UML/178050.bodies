class LoadMapFile
!!!418178.java!!!	LoadMapFile(in fileName : String, inout append : boolean)
		
		File f = new File(fileName);
		
		if (append) {
			if (!f.isFile()) {
				if (!f.createNewFile()) {
					throw new IOException("Unable to create new file.");
				}
			}
			
			file = new RandomAccessFile(fileName, "rws");
			channel = file.getChannel();
			file.seek(file.length());
		} else {
			if (!f.isFile()) {
				throw new IOException("Unable to open file \"" + fileName + "\".");
			}
			
			file = new RandomAccessFile(fileName, "r");
			channel = file.getChannel();
		}
		
		buffer = ByteBuffer.allocateDirect(BUFFER_ENTRY_COUNT * FileEntry.ENTRY_SIZE);
!!!418306.java!!!	readFrom(in index : int) : FileEntry
		
		int count = 0;
		
		try {
			count = getCount();
		} catch (IOException e) {
			throw new InputParseException("Unable to determine file size.", e);
		}
		
		if ((index < 0) || (index >= count)) {
			throw new IndexOutOfBoundsException("Entry index out of bounds.");
		}
		
		try {
			file.seek(index * FileEntry.ENTRY_SIZE);
		} catch (IOException e) {
			throw new InputParseException("Error seeking in the file.", e);
		}
		
		ByteBuffer buf = ByteBuffer.allocate(FileEntry.ENTRY_SIZE);
		int bytes = 0;
		
		try {
			bytes = channel.read(buf);
		} catch (IOException e) {
			throw new InputParseException("Unable to read data from channel.", e);
		}
		
		if (bytes < FileEntry.ENTRY_SIZE) {
			throw new InputParseException("Unable to read whole entry.");
		}
		
		buf.rewind();
		
		FileEntry entry = new FileEntry();
		
		entry.load(buf);
		
		return entry;
!!!418434.java!!!	readFrom(in index : int, in n : int) : FileEntry

		MiscUtils.verifyIntParameterGZero(n, "n");
		
		int count = 0;
		
		try {
			count = getCount();
		} catch (IOException e) {
			throw new InputParseException("Unable to determine file size.", e);
		}
		
		if ((index < 0) || (index >= count)) {
			throw new IndexOutOfBoundsException("Entry index out of bounds.");
		}
		
		try {
			file.seek(index * FileEntry.ENTRY_SIZE);
		} catch (IOException e) {
			throw new InputParseException("Error seeking in the file.", e);
		}

		ArrayList< FileEntry > entries = new ArrayList< FileEntry >(n);
		
		int bytes = 0;
		int entriesRead = 0;
		
		while (entriesRead < n) {
			
			buffer.clear();
			
			try {
				bytes = channel.read(buffer);
			} catch (IOException e) {
				throw new InputParseException("Unable to read data from channel.", e);
			}
			
			if (bytes < 0) {
				break;
			}
			
			if (bytes % FileEntry.ENTRY_SIZE != 0) {
				throw new InputParseException("Unable to read whole entry. Read " + bytes + " bytes.");
			}
			
			int ec = bytes / FileEntry.ENTRY_SIZE;

			buffer.rewind();

			for (int i = 0; i < ec; ++i) {
				FileEntry entry = new FileEntry();
				
				entry.load(buffer);
				
				entries.add(entry);
			}
			
			entriesRead += ec;
		}
		
		return entries;
!!!418562.java!!!	append(inout entry : FileEntry) : int
		
		int count = 0;
		
		count = getCount();

		buffer.clear();
		
		entry.store(buffer);
		
		buffer.flip();
		
		try {
			channel.write(buffer);
		} catch (IOException e) {
			throw new OutputWriteException("Unable to write output.", e);
		}
		
		return count + 1;
!!!418690.java!!!	append(inout entry : FileEntry) : int

		int count = 0;
		
		count = getCount();

		int index = 0;
		
		while (index < entry.length) {

			buffer.clear();
			
			for (int q = 0; (index < entry.length) && (q < BUFFER_ENTRY_COUNT); ++q, ++index) {
				entry[index].store(buffer);
			}
			
			buffer.flip();
			
			try {
				channel.write(buffer);
			} catch (IOException e) {
				throw new OutputWriteException("Unable to write output.", e);
			}
		}

		return count + entry.length;
!!!418818.java!!!	append(inout entry : Collection< FileEntry >) : int
		
		int count = 0;
		
		count = getCount();
		
		Iterator< FileEntry > it = entry.iterator();
		
		while (it.hasNext()) {
			
			buffer.clear();
			
			for (int q = 0; it.hasNext() && (q < BUFFER_ENTRY_COUNT); ++q) {
				FileEntry e = it.next();
				e.store(buffer);
			}
			
			buffer.flip();
			
			try {
				channel.write(buffer);
			} catch (IOException e) {
				throw new OutputWriteException("Unable to write output.", e);
			}
		}
		
		return count + entry.size();
!!!418946.java!!!	close() : void
		
		file.close();
!!!419074.java!!!	finalize() : void
		
		try {
			file.close();
		} finally {
			super.finalize();
		}
!!!419202.java!!!	getCount() : int
		
		return (int) (file.length() / FileEntry.ENTRY_SIZE);
