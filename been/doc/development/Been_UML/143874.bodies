class TimestampBasedVersionProvider
!!!206722.java!!!	getVersions() : ExperimentMetadata

		HashSet<Long> processedTimestamps = convertVersionsToTimestamps();
		
		SchedulerEntry entry = createSchedulerEntry(schedule);
		LinkedList<ExperimentMetadata> newExperiments = new LinkedList<ExperimentMetadata>();
		newVersions = new LinkedList<Version>();
		
		final long now =System.currentTimeMillis();
		
		/*
		 * We have no historical start and no last run to start from
		 * so we will count what would last run be by going to the history by one minute
		 * until we get "historical" alarm time
		 */
		long lastRunTime = lastRun;
		long finish;
		
		/*
		 * -----[lastrun]-----------[current]---[now]----------[nextrun]-------
		 * 1. We update entry with current time => it return "nextrun" alarmtime somewhere in future
		 * 2. We go back to history -> when first for finishes, we have "current" alarmtime
		 * 3. This corresponds to the current execution time, we should not detect version after it
		 * 3. We go back to history -> when second "for" finished, we have "lastrun" alarmtime
		 * 4. This would have been our last alarmtime if we were running. If we don't have previous time, we use this one. 
		 */
		entry.updateAlarmTime(now);
		long lastAlarm = entry.getAlarmTime();
		for (long history = now; lastAlarm == entry.getAlarmTime(); entry.updateAlarmTime(history -= 60000));
		lastAlarm = entry.getAlarmTime();
		finish = entry.getAlarmTime();
		for (long history = entry.getAlarmTime(); lastAlarm == entry.getAlarmTime(); entry.updateAlarmTime(history -= 60000));
		// entry "switched" to the previous alarm time, what would have been our "last" alarm time
		if (lastRunTime == FIRST_RUN) {
			lastRunTime = entry.getAlarmTime();
		}

		/*
		 * Process user-defined boundaries
		 */
		long nextTime;
		if (historicalStart == NO_START) {
			// user did not specify lower boundary -> start from previous run
			nextTime = lastRunTime;
		} else {
			// lower boundary is in the future -> we must not detect anything
			if (historicalStart > now) {
				return new ExperimentMetadata[0];
			}

			/*
			 * If we run for the first time and historical start is in history, we will always start from there
			 */
			if (lastRun == FIRST_RUN) {
				nextTime = historicalStart;
			} else {
				/*
				 * We are not running for the first time, so we should create only version after previous run
				 * -> use "later" value from lower boundary and last run
				 */ 
				nextTime = Math.max(historicalStart,lastRunTime);
			}
			
		}
		
		/*
		 * We have already counted our upper boundary which is "current" execution of entry
		 * We just need to verify, whether this is inside user's boundary
		 */
		if (historicalEnd != NO_END) {
			finish = Math.min(finish,historicalEnd);
		}
		
		// we need to start with the next minute after the last run -> remove seconds and add one minute
		nextTime = ((nextTime / 60000) * 60000);
		finish = (finish /60000) * 60000;
		
		/*
		 *  We will use the entry to derive historical executions 
		 */
		do {
			entry.updateAlarmTime(nextTime);
			nextTime = entry.getAlarmTime();
			if (nextTime > finish) {
				break;
			}
			if (processedTimestamps.contains(nextTime)) {
				// we already have this version processed
				continue;
			}
			newExperiments.add(handleTimestamp(nextTime));
			newVersions.add(new Version(String.valueOf(nextTime)));
		} while (nextTime < finish);
		
		// finally keep contract - update versions and return new experiments
		return newExperiments.toArray(new ExperimentMetadata[newExperiments.size()]);
!!!206850.java!!!	convertVersionsToTimestamps() : HashSet<Long>
		HashSet<Long> set = new HashSet<Long>((processedVersions.length << 1 ) + (processedVersions.length >> 1));
		for (Version v : processedVersions) {
			set.add(Long.parseLong(v.getPart(0)));
		}
		
		return set;
!!!207106.java!!!	getProcessedVersions() : Version
		return newVersions.toArray(new Version[newVersions.size()]);
!!!207234.java!!!	createSchedulerEntry(inout newSchedule : SchedulerInfo) : SchedulerEntry
		SchedulerEntry entry = new SchedulerEntry(
				"dummy",
				newSchedule.getMinutes(),
				newSchedule.getHours(),
				newSchedule.getDaysOfMonth(),
				newSchedule.getMonths(),
				newSchedule.getDaysOfWeek(),
				newSchedule.getYear(),
				null
				);
		return entry;
