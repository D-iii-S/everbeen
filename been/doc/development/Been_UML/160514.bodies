class HostDatabaseEngine
!!!340098.java!!!	HostDatabaseEngine(in dbPath : String, inout logger : HostManagerLogger)
		
		this.logger = logger;
		this.logger.logInfo("Initialising database engine.");
		this.logger.logInfo("Database path is: \"" + dbPath + "\".");
		
		if ((dbPath == null) || (dbPath.length() == 0)) {
			throw new InvalidArgumentException("Illegal path to the database directory.");
		}
		
		databasePath = dbPath;

		if (databasePath.endsWith(File.separator)) {
			databasePath += File.separator;
		}

		// test whether database already exists
		File db = new File(databasePath);
		
		if (!db.exists()) {
			createDatabase();
		}
		
		// Load database.
		load();
		
		// NOTE: do not forget to change this regexp if property syntax changes.
		substitutor = new SubstituteVariableValues("[\\p{Alpha}_]+");
!!!340226.java!!!	load() : void
	
		long timeStart = System.currentTimeMillis();
		
		this.logger.logInfo("Loading data...");
		
		try {
			dbIndex = new DatabaseIndex(getFullFileName(DATABASE_INDEX_NAME), logger);
		} catch (InputParseException e) {
			this.logger.logError("Error parsing index file.", e);
			throw new HostDatabaseException(e);
		}	
	
		HostIndexEntry []list = dbIndex.getHostEntryList();
		
		hostData = new HashMap< String, HostInfo >();

		for (int i = 0; i < list.length; ++i) {

			HostInfo hi = null;
			
			try {
				FileInputStream inputStream = 
					new FileInputStream(getFullFileName(list[i].getDataFileName()));
				
				hi = new HostInfo(new InputSource(inputStream));
			} catch (FileNotFoundException e) {
				this.logger.logError("Unable to find host from the index.");
				dbIndex.removeHostEntry(list[i].getHostName());
				continue;
			} catch (InputParseException e) {
				this.logger.logError("Error parsing host file.", e);
				dbIndex.removeHostEntry(list[i].getHostName());
				continue;
			}
			
			if (hostData.put(list[i].getHostName(), hi) != null) {
				// Host was already in database, we have overwritten previous one
				this.logger.logError("Duplicate host: " + list[i].getHostName());
			}
		}
		
		this.logger.logInfo("Loading group data...");

		GroupIndexEntry []groupList = dbIndex.getGroupEntryList();
		
		groupData = new HashMap< String, HostGroup >();
		
		String defaultGroupMeta = "";
		String defaultGroupDesc = "";
		
		for (int i = 0; i < groupList.length; ++i) {

			HostGroup hg = null;
			
			try {
				FileInputStream input = new FileInputStream(getFullFileName(groupList[i].getDataFileName()));
				
				hg = new HostGroup(new InputSource(input));
			} catch (FileNotFoundException e) {
				this.logger.logError("Unable to find group from the index (name: \""
						+ groupList[i].getGroupName() + "\").");
				dbIndex.removeGroupEntry(groupList[i].getGroupName());
				continue;
			} catch (InputParseException e) {
				this.logger.logError("Error parsing group file (group: \"" + groupList[i].getGroupName()
						+ "\", file:\"" + groupList[i].getDataFileName() + "\").", e);
				dbIndex.removeGroupEntry(groupList[i].getGroupName());
				continue;
			}
			
			if (groupData.containsKey(hg.getName())) {
				this.logger.logError("Group \"" + hg.getName() + "\" is already in database. "
						+ "Older entry will be overwritten.");
			}

			// we have found default group
			if (hg.isDefaultGroup()) {
				if (hg.getDescription().length() > 0) {
					defaultGroupDesc = hg.getDescription();
				}
				
				if (hg.getMetadata().length() > 0) {
					defaultGroupMeta = hg.getMetadata();
				}
			} else {
				if (!checkGroupIntegrity(hg, false)) {
					String fileName = getFullFileName(groupList[i].getDataFileName());
					try {
						XMLHelper.saveXMLSerializable(hg, fileName, true, "UTF-16");
					} catch (Exception e) {
						this.logger.logError("Unable to save repaired group \"" + hg.getName()
								+ "\".", e);
					}
				}
				
				groupData.put(hg.getName(), hg);
			}
		}

		// construct default group with description and metadata found in database.
		// we do this because it is simpler than checking all hosts in group and adding/removing
		// some of them
		HostGroup newDefaultGroup = new HostGroup(HostGroup.DEFAULT_GROUP_NAME);
		
		for (String curHostName : hostData.keySet()) {
			newDefaultGroup.addHost(curHostName);
		}
		
		newDefaultGroup.setDescription(defaultGroupDesc);
		newDefaultGroup.setMetadata(defaultGroupMeta);

		if (dbIndex.hasGroupEntry(HostGroup.DEFAULT_GROUP_NAME)) {
			File oldGroupFile = 
				new File(getFullFileName(dbIndex.getGroupEntry(HostGroup.DEFAULT_GROUP_NAME).getDataFileName()));
			
			if (!oldGroupFile.delete()) {
				this.logger.logFatal("Unable to remove old default group file.");
				throw new HostDatabaseException("Unable to remove old default group file.");
			}
			
			dbIndex.removeGroupEntry(HostGroup.DEFAULT_GROUP_NAME);
		}

		String newGroupFileName = getUniqueFileName("0", "group");

		dbIndex.addGroupEntry(HostGroup.DEFAULT_GROUP_NAME, newGroupFileName);
		
		groupData.put(HostGroup.DEFAULT_GROUP_NAME, newDefaultGroup);
		
		try {
			XMLHelper.saveXMLSerializable(newDefaultGroup, getFullFileName(newGroupFileName), true, "UTF-16");
		} catch (Exception e) {
			this.logger.logFatal("Unable to save default group.", e);
			throw new HostDatabaseException("Unable to save default group.", e);
		}
		
		// save index if any modification have been made
		dbIndex.save();
		updateGroupProperty();

		// load definition file for software aliases
		this.logger.logInfo("Loading alias definition file.");
		try {
			aliases = new SoftwareAliasList(getFullFileName(ALIAS_DEFINITION_FILE));
		} catch (Exception e) {
			this.logger.logError("Unable to load alias definition file.", e);
			this.logger.logInfo("Creating empty alias definition file.");
			
			aliases = new SoftwareAliasList();
			
			try {
				aliases.save(getFullFileName(ALIAS_DEFINITION_FILE));
			} catch (Exception f) {
				this.logger.logFatal("Unable to save new alias definition file.", e);
				throw new HostDatabaseException("Unable to save new alias definition file.", e);
			}
		}
		long timeEnd = System.currentTimeMillis();
		
		this.logger.logInfo("Data loaded in " + (timeEnd - timeStart) + " ms.");
!!!340354.java!!!	terminate() : void
		
		try {
			dbIndex.save();
		} catch (Exception e) {
			logger.logError("Error saving index during database termination.");
		}
		
		try {
			aliases.save(getFullFileName(ALIAS_DEFINITION_FILE));
		} catch (Exception e) {
			logger.logError("Error saving alias definitions during database termination.");
		}
!!!340482.java!!!	createDatabase() : void
		
		logger.logWarning("Database directory does not exist. Creating empty database.");
		
		File dataDir = new File(databasePath);
		
		if (!dataDir.mkdirs()) {
			throw new HostDatabaseException("Unable to create database directory.");
		}
!!!340610.java!!!	addHost(in hostName : String, in data : String, in detectorEncoding : String) : void
		
		if (isHost(hostName)) {
			
			logger.logError("Attempted to add host which is already in database, host name \""
					+ hostName + "\".");
			throw new HostManagerException("Unable to add host which is already in database (\""
					+ hostName + "\").");
		}

		synchronized (this) {
			StringReader reader = new StringReader(data);
			
			HostInfo newHostInfo = null;
			
			try {
				newHostInfo = new HostInfo(new InputSource(reader));
			} catch (InputParseException e) {
				logger.logError("Invalid data received for host \"" + hostName + "\".", e);
				throw new InvalidArgumentException("Invalid data received for host \"" + hostName + "\"", e);
			}
			
			buildAliasTable(newHostInfo);
			
			String fileSuffix = MiscUtils.formatDate(newHostInfo.getCheckDateTime(), "-yyyy-MM-dd-HH-mm-ss");
			String dataFileName = getUniqueFileName(hostName + fileSuffix, "host");
			String loadFileName = getUniqueFileName(hostName, "load");
			String loadMapFileName = getUniqueFileName(hostName, "loadmap");
			
			try {
				XMLHelper.saveXMLSerializable(newHostInfo, 
						getFullFileName(dataFileName), true, detectorEncoding);
			} catch (Exception e) {
				logger.logError("Unable to save data file for host \"" + hostName + "\".", e);
				throw new HostDatabaseException("Unable to save data file for host \"" + hostName + "\"", e);
			}
	
			hostData.put(hostName, newHostInfo);
	
			dbIndex.addHostEntry(hostName, dataFileName, loadFileName, 
					loadMapFileName, newHostInfo.getCheckDateTime());			
			
			createEmptyLoadFiles(hostName);
	
			try {
				dbIndex.save();
			} catch (HostDatabaseException e) {
				logger.logError("Unable to update index after adding host.");
				throw e;
			}
			
			HostGroup defaultGroup = groupData.get(HostGroup.DEFAULT_GROUP_NAME);
			
			defaultGroup.addHost(hostName);
			
			try {
				String groupFileName = dbIndex.getGroupEntry(HostGroup.DEFAULT_GROUP_NAME).getDataFileName();
				
				XMLHelper.saveXMLSerializable(defaultGroup, 
				                              getFullFileName(groupFileName), 
				                              true, 
				                              "UTF-16");
			} catch (Exception e) {
				logger.logError("Unable to update default group.", e);
				throw new HostDatabaseException("Unable to save default group.", e);
			}

			updateGroupProperty();
		}
!!!340738.java!!!	refreshHost(in hostName : String, in newData : String, in detectorEncoding : String) : void
		
		if (!isHost(hostName)) {
			logger.logError("Unable to refresh host \"" + hostName + "\" which is not in database.");
			throw new ValueNotFoundException("Unable to refresh host \"" + hostName
					+ "\", host is not in database.");
		}
		
		synchronized (this) {
			StringReader reader = new StringReader(newData);
			
			HostInfo newHostInfo = null;
			
			try {
				newHostInfo = new HostInfo(new InputSource(reader));
			} catch (InputParseException e) {
				logger.logError("Invalid data received for host \"" + hostName + "\". "
						+ "Parser message: " + e.getMessage());
				throw new InvalidArgumentException("Invalid data received for host \"" + hostName + "\"", e);
			}
	
			buildAliasTable(newHostInfo);
			
			String fileSuffix = MiscUtils.formatDate(newHostInfo.getCheckDateTime(), "-yyyy-MM-dd-HH-mm-ss");
			String dataFileName = getUniqueFileName(hostName + fileSuffix, "host");
			
			try {
				XMLHelper.saveXMLSerializable(newHostInfo, getFullFileName(dataFileName), true, detectorEncoding);
			} catch (Exception e) {
				logger.logError("Unable to save data file for host \"" + hostName + "\".", e);
				throw new HostDatabaseException("Unable to save host \"" + hostName + "\"", e);
			}
			
			try {
				HostIndexEntry he = dbIndex.getHostEntry(hostName);
				he.addNewEntry(newHostInfo.getCheckDateTime(), dataFileName);
			} catch (Exception e) {
				logger.logError("Unable to add new entry to the index, host name \"" + hostName + "\".", e);
	
				// try to remove data file
				File file = new File(getFullFileName(dataFileName));
				
				if (!file.delete()) {
					logger.logWarning("Unable to delete data file for host \"" + hostName + "\""
							+ ", file \"" + file.getAbsolutePath() + "\".");
				}
				
				throw new HostDatabaseException("Unable to add entry to the history.", e);
			}
	
			try {
				dbIndex.save();
			} catch (HostDatabaseException e) {
				logger.logError("Unable to update index after host refresh.");
				throw e;
			}
			
			// update data in map
			hostData.put(hostName, newHostInfo);
			
			updateGroupProperty();
		}
!!!340866.java!!!	removeHost(in name : String) : void
		
		if (hostData.containsKey(name)) {
			
			// remove host from all groups that contain it.
			for (Iterator< Map.Entry< String, HostGroup > > it = groupData.entrySet().iterator();
			     it.hasNext(); ) {
				
				HostGroup current = it.next().getValue();
				
				if (current.containsHost(name)) {
					current.removeHost(name);
					
					String groupFileName = 
						getFullFileName(dbIndex.getGroupEntry(current.getName()).getDataFileName());

					// save group to the file
					try {
						XMLHelper.saveXMLSerializable(current, groupFileName, true, "UTF-16");
					} catch (Exception e) {
						logger.logError("Unable to save group \"" + current.getName() + "\".", e);
						throw new HostDatabaseException("Unable to save group \""
								+ current.getName() + "\"", e);
					}
				}
			}
			
			HostIndexEntry entry = null;
			
			try {
				entry = dbIndex.getHostEntry(name);
			} catch (Exception e) {
				// this should never happen, since we checked for the presence of the host earlier
				assert false : "removeHost: index is out of sync with hostData.";
			}
			
			// remove history files
			for (Pair< Date, String > current: entry.getHistoryEntryList()) {
				String entryFileName = current.getSecond();
				File entryFile = new File(getFullFileName(entryFileName));
				
				if (!entryFile.delete()) {
					logger.logWarning("Unable to remove entry file \"" + entryFileName + "\".");
				}
			}
			
			deleteLoadFiles(name);
			
			// remove host data from table.
			hostData.remove(name);
			
			// remove entry from index
			dbIndex.removeHostEntry(name);
			dbIndex.save();			
		} else {
			logger.logError("Unable to remove host \"" + name + "\", "
					+ "host was not found in database.");
			throw new ValueNotFoundException("Unable to remove host \"" + name + "\", "
					+ "host was not found in database."); 
		}
!!!340994.java!!!	findHost(in name : String) : HostInfoInterface
		
		HostInfo result = hostData.get(name);
		
		if (result != null) {
			return result;
		} else {
			throw new ValueNotFoundException("Host \"" + name + "\" was not found in database.");
		}
!!!341122.java!!!	isHost(in name : String) : boolean
		
		return hostData.containsKey(name);
!!!341250.java!!!	getHostNames() : String
		
		String []res = new String[hostData.keySet().size()];
		
		hostData.keySet().toArray(res);
		
		return res;
!!!341378.java!!!	queryHosts(inout restrictions : RestrictionInterface) : ArrayList< String >
		
		ArrayList< String > result = new ArrayList< String >();
		
		for (Iterator< HostInfo > it = hostData.values().iterator(); it.hasNext(); ) {
			
			HostInfo current = it.next();
			
			if (current.test(restrictions, true)) {
				result.add(current.getHostName());
			}
		}
		
		return result;
!!!341506.java!!!	queryHosts(inout query : HostQueryCallbackInterface) : ArrayList< String >
		
		ArrayList< String > result = new ArrayList< String >();
		
		for (Iterator< HostInfo > it = hostData.values().iterator(); it.hasNext(); ) {
			
			HostInfo current = it.next();
			
			if (query.match(current)) {
				result.add(current.getHostName());
			}
		}
		
		return result;
!!!341634.java!!!	getHostHistoryDates(in name : String) : List< Date >

		try {
			return dbIndex.getHostEntry(name).getHistoryEntryDates();
		} catch (ValueNotFoundException e) {
			throw new ValueNotFoundException("Unable to retrieve history dates for \"" + name
					+ "\", " + "host not found in database.", e);
		}
!!!341762.java!!!	getHostHistoryEntry(in name : String, inout date : Date) : HostInfoInterface
		
		String hiFile = dbIndex.getHostEntry(name).getHistoryEntry(date);
			
		try {
			HostInfo hi = new HostInfo(new InputSource(new FileInputStream(getFullFileName(hiFile)))); 
			
			return hi;
		} catch (Exception e) {
			throw new HostDatabaseException("Error parsing input file for \"" + name + "\".", e);
		}
!!!341890.java!!!	removeHostHistoryEntry(in hostName : String, inout date : Date) : void

		HostIndexEntry hie = dbIndex.getHostEntry(hostName);
		String entryFile = hie.getHistoryEntry(date);
		File f = new File(getFullFileName(entryFile));
		
		if (!f.delete()) {
			throw new HostDatabaseException("Unable to remove entry file for date \""
					+ MiscUtils.formatDate(date, HostManagerInterface.DEFAULT_DATE_TIME_FORMAT) + "\".");
		}
		
		hie.removeHistoryEntry(date);
				
		dbIndex.save();
!!!342018.java!!!	addGroup(inout group : HostGroup) : void
		
		if (group.isDefaultGroup()) {
			// user is not permitted to add another default group
			throw new InvalidArgumentException("Can't add default group.");
		}
		
		if (isGroup(group.getName())) {
			// names of groups must be unique
			throw new InvalidArgumentException("Duplicate group name \"" + group.getName() + "\".");
		}
		
		// Generate name of the file in which group will be saved. We can't use name of the group
		// as we use for .host files, since group name can contain any characters. We will use
		// current time as the base for the group group name. 
		String newFileName = getUniqueFileName(String.valueOf(System.currentTimeMillis()), "group");

		try {
			XMLHelper.saveXMLSerializable(group, getFullFileName(newFileName), true, "UTF-16");
		} catch (Exception e) {
			logger.logError("Unable to save group \"" + group.getName() + "\" to file.", e);
			throw new HostDatabaseException("Unable to save group \"" + group.getName() + "\".", e);
		}

		dbIndex.addGroupEntry(group.getName(), newFileName);
		
		dbIndex.save();
		
		groupData.put(group.getName(), group);
		
		updateGroupProperty();
!!!342146.java!!!	removeGroup(in name : String) : void
		
		if (!isGroup(name)) {
			
			throw new ValueNotFoundException("Unable to remove non-existant group \"" + name + "\".");
		}
		
		String fileName = dbIndex.getGroupEntry(name).getDataFileName();
		
		File groupFile = new File(getFullFileName(fileName));
		
		if (!groupFile.delete()) {
			throw new HostDatabaseException("Unable to remove group file \"" + fileName + "\".");
		}
		
		groupData.remove(name);
		
		dbIndex.removeGroupEntry(name);
		
		dbIndex.save();
		
		updateGroupProperty();
!!!342274.java!!!	updateGroup(inout group : HostGroup) : void

		if (!checkGroupIntegrity(group, true)) {
			logger.logError("Unable to modify group \"" + group.getName()
					+ "\" because new group is invalid.");
			throw new InvalidArgumentException("Unable to modify group \"" + group.getName()
					+ "\" because new group is invalid.");
		}
		
		HostGroup original = groupData.get(group.getName());
		
		if (original == null) {
			throw new ValueNotFoundException("Unable to find group \"" + group.getName()
					+ "\" needed for update.");
		}

		String originalFile = getFullFileName(dbIndex.getGroupEntry(original.getName()).getDataFileName());
		
		original.setDescription(group.getDescription());
		original.setMetadata(group.getMetadata());
		
		if (!original.isDefaultGroup()) {
			// if group is not default, we will modify list of hosts
			original.removeAllHosts();
			original.addGroup(group);
		}
		
		try {
			XMLHelper.saveXMLSerializable(original, originalFile, true, "UTF-16");
		} catch (Exception e) {
			throw new HostManagerException("Unable to update group \"" + original.getName() + "\".", e);
		}
		
		groupData.put(group.getName(), group);
		
		updateGroupProperty();
!!!342402.java!!!	renameGroup(in oldName : String, in newName : String) : void
		
		HostGroup oldGroup = findGroup(oldName);
		
		if (oldGroup.isDefaultGroup()) {
			throw new InvalidArgumentException("You cannot rename default group.");
		}
		
		if (isGroup(newName)) {
			throw new InvalidArgumentException("Unable to rename \"" + oldName + "\" to \""
					+ newName + "\". Group with new name already exists.");
		}
		
		HostGroup newGroup = new HostGroup(newName);
		
		newGroup.setDescription(oldGroup.getDescription());
		newGroup.setMetadata(oldGroup.getMetadata());
		newGroup.addGroup(oldGroup);
		
		removeGroup(oldName);
		
		addGroup(newGroup);
		
		updateGroupProperty();
!!!342530.java!!!	findGroup(in name : String) : HostGroup
		
		HostGroup group = groupData.get(name);
		
		if (group != null) {
			return group;
		} else {
			throw new ValueNotFoundException("Group \"" + name + "\" was not found in database.");
		}
!!!342658.java!!!	getGroupNames() : String
		
		String []result = new String[groupData.size()];
		
		groupData.keySet().toArray(result);
		
		return result;
!!!342786.java!!!	isGroup(in name : String) : boolean
		
		return groupData.containsKey(name);
!!!342914.java!!!	getDatabasePath() : String
		
		return databasePath;
!!!343042.java!!!	memberOf(in hostName : String) : String
		
		if (hostData.containsKey(hostName)) {
			ArrayList< String > mof = new ArrayList< String >();
		
			for (Iterator< HostGroup > it = groupData.values().iterator(); it.hasNext(); ) {
				
				HostGroup current = it.next();
				
				if (current.containsHost(hostName)) {
					
					mof.add(current.getName());
				}
			}
			
			return (String []) mof.toArray();
		} else {
			return null;
		}
!!!343170.java!!!	getHostCount() : int
		
		return hostData.size();
!!!343298.java!!!	getGroupCount() : int
		
		return groupData.size();
!!!343426.java!!!	findMatchingHosts(inout conditions : RestrictionInterface) : ArrayList< String >
		
		ArrayList< String > result = new ArrayList< String >();
		
		for (HostInfo hi: hostData.values()) {
			
			if (hi.test(conditions, true)) {
				
				result.add(hi.getHostName());
			}
		}
		
		return result;
!!!343554.java!!!	findMatchingHosts(inout callback : HostQueryCallbackInterface) : ArrayList< String >
		
		ArrayList< String > result = new ArrayList< String >();
		
		for (HostInfo hi: hostData.values()) {
			
			if (callback.match(hi)) {
				
				result.add(hi.getHostName());
			}
		}
		
		return result;
!!!343682.java!!!	getAliasDefinitionCount() : int
		
		return aliases.getAliasCount();
!!!343810.java!!!	getAliasDefinitition(in i : int) : SoftwareAliasDefinition
		
		return aliases.get(i);
!!!343938.java!!!	addAliasDefinition(inout ad : SoftwareAliasDefinition) : int
		
		aliases.add(ad);
		
		aliases.save(getFullFileName(ALIAS_DEFINITION_FILE));
		
		return aliases.getAliasCount() - 1;
!!!344066.java!!!	addAliasDefinitionList(inout ads : Iterable< SoftwareAliasDefinition >) : void
		
		for (SoftwareAliasDefinition a: ads) {
			aliases.add(a);
		}
		
		aliases.save(getFullFileName(ALIAS_DEFINITION_FILE));
!!!344194.java!!!	removeAliasDefinition(in index : int) : void
		
		aliases.remove(index);
		
		aliases.save(getFullFileName(ALIAS_DEFINITION_FILE));
!!!344322.java!!!	removeAllAliasDefinitions() : void
		
		aliases.removeAll();
		
		aliases.save(getFullFileName(ALIAS_DEFINITION_FILE));
!!!344450.java!!!	rebuildAliasTableForAllHosts() : void

		long timeStart = System.currentTimeMillis();
		
		logger.logInfo("Rebuilding database...");
		
		for (HostInfo hi: hostData.values()) {
			try {
				hi.removeAllAliases();
			} catch (Exception e) {
				logger.logError("Unable to rebuild alias table, error removing aliases from "
						+ "\"" + hi.getHostName() + "\".");
				throw new HostDatabaseException("Error removing aliases from host \""
						+ hi.getHostName() + "\".", e);
			}
			
			buildAliasTable(hi);
			
			try {
				String fileName = 
					getFullFileName(dbIndex.getHostEntry(hi.getHostName()).getDataFileName());

				XMLHelper.saveXMLSerializable(hi, fileName, true, "UTF-16");
			} catch (Exception e) {
				logger.logError("Unable to save data for \"" + hi.getHostName() + "\".");
				throw new HostDatabaseException("Unable to save data for \"" 
						+ hi.getHostName() + "\".", e);
			}
		}

		long timeEnd = System.currentTimeMillis();
		
		logger.logInfo("Rebuld finished in " + (timeEnd - timeStart) + " ms.");
!!!344578.java!!!	checkGroupIntegrity(inout hg : HostGroup, inout readOnly : boolean) : boolean
	
		HashSet< String > toRemove = new HashSet< String >();
		boolean hasError = false;

		// Test all hosts in group. If host is not in database, remove it from the group.
		for (String hostName: hg) {
			
			if (!hostData.containsKey(hostName)) {
			
				logger.logWarning("Host \"" + hostName + "\" from group \"" + hg.getName()
						+ "\" is not in database. Removing...");
				
				// Add host to the list of to-be-removed hosts. 
				toRemove.add(hostName);
				hasError = true;
			}
		}
		
		if (!readOnly) {
			for (String hName: toRemove) {
				
				hg.removeHost(hName); 
			}
		}

		// additional checks for default group
		if (hg.isDefaultGroup()) {
			if (readOnly) {
				if (!hasError) {
					if (getHostCount() != hg.getHostCount()) {
						// number of hosts in group does not equal to number of all hosts, 
						// so group is invalid
						hasError = true;
					} else {
						// same number of hosts, we have to check them one-by-one
						String []hostNames = getHostNames();
						
						for (String current: hostNames) {
							if (!hg.containsHost(current)) {
								hasError = true;
								break;
							}
						}
					}
				}
			} else {
				// this is sufficient test, since we have already removed invalid hosts
				if (hg.getHostCount() != getHostCount()) {
					// some hosts are missing in the group, we need to add all of them to the group
					logger.logWarning("Adding missing hosts to the default group (count: "
							+ hg.addHosts(getHostNames()) + ").");
					
					hasError = true;
				}				
			}
		}
		
		return !hasError;
!!!344706.java!!!	getHostNamesIterator() : Iterator< String >
		
		return new HostNameIterator();
!!!344834.java!!!	getGroupNamesIterator() : Iterator< String >
		
		return new GroupNameIterator();
!!!344962.java!!!	updateUserProperties(in hostName : String, inout newProps : PropertyTreeInterface) : void
		
		HostInfo host = hostData.get(hostName);
		
		if (host == null) {
			throw new InvalidArgumentException("Host \"" + hostName + "\" not found in database.");
		}
		
		host.setUserPropertiesObject(newProps);
		
		String hostFile = null;
		
		try {
			hostFile = getFullFileName(dbIndex.getHostEntry(hostName).getDataFileName());
		} catch (Exception e) {
			assert false : "Index is out of sync with db.";
		}
		
		try {
			XMLHelper.saveXMLSerializable(host, hostFile, true, "UTF-16");
		} catch (Exception e) {
			logger.logError("Unable to save new host file.", e);
			throw new HostDatabaseException("Unable to save new host file.", e);
		}
!!!345090.java!!!	deleteFile(in name : String) : void
		
		String fname = getFullFileName(name);
		
		File file = new File(fname);
		
		if (!file.exists()) {
			throw new FileNotFoundException("Unable to find file \"" + name + "\".");
		}
		
		if (!file.delete()) {
			throw new HostDatabaseException("Unable to delete file: \"" + name + "\".");
		}
!!!345218.java!!!	getLoadFileName(in hostName : String) : String

		HostIndexEntry entry = dbIndex.getHostEntry(hostName);
		
		return entry.getLoadFileName();
!!!345346.java!!!	getLoadMapFileName(in hostName : String) : String

		HostIndexEntry entry = dbIndex.getHostEntry(hostName);
		
		return entry.getLoadMapFileName();
!!!345474.java!!!	getLoadFilePath(in hostName : String) : String
		
		return getFullFileName(getLoadFileName(hostName));
!!!345602.java!!!	getLoadMapFilePath(in hostName : String) : String
		
		return getFullFileName(getLoadMapFileName(hostName));
!!!345730.java!!!	deleteLoadFiles(in hostName : String) : void
		
		String fileName = getLoadFileName(hostName);
		String mapFileName = getLoadMapFileName(hostName);
		
		try {
			deleteFile(fileName);
		} catch (Exception e) {
			logger.logError("Unable to delete load file for \"" + hostName + "\".");
			throw new HostDatabaseException("Unable to delete load file for \"" + hostName + "\".", e);
		}
		
		try {
			deleteFile(mapFileName);
		} catch (Exception e) {
			logger.logError("Unable to delete load map file for \"" + hostName + "\".");
			throw new HostDatabaseException("Unable to delete load map file for \"" + hostName + "\".", e);
		}
!!!345858.java!!!	createEmptyLoadFiles(in hostName : String) : Pair
		
		HostIndexEntry entry = dbIndex.getHostEntry(hostName);
		
		File loadFile = new File(getFullFileName(entry.getLoadFileName()));
		try {
			if (!loadFile.createNewFile()) {
				// file already exists
				new FileWriter(loadFile, false);
			}
		} catch (IOException e) {
			throw new HostDatabaseException("Unable to create load file.", e);
		}
		
		File mapFile = new File(getFullFileName(entry.getLoadMapFileName()));
		try {
			if (!mapFile.createNewFile()) {
				// file already exists
				new FileWriter(mapFile, false);
			}
		} catch (IOException e) {
			throw new HostDatabaseException("Unable to create new load map file.");
		}
		
		return new Pair< String, String >(loadFile.getAbsolutePath(), mapFile.getAbsolutePath());
!!!345986.java!!!	getFullFileName(in fn : String) : String
		
		return MiscUtils.concatenatePath(databasePath, fn);
!!!346114.java!!!	findInArray(in s : String, in a : String) : boolean

		if (a != null) {
			for (int i = 0; i < a.length; ++i) {
				
				if (a[i].equals(s)) {
					return true;
				}
			}
		}
		
		return false;
!!!346242.java!!!	getUniqueFileName(in entityName : String, in ext : String) : String
		
		File dbDirFile = new File(databasePath);
		
		String []fileList = dbDirFile.list(new ExtensionFileFilter(ext));
		
		String result = entityName;

		if (findInArray(result + "." + ext, fileList)) {
			
			int add = 0;
			
			while (findInArray(result + "_" + String.valueOf(add) + "." + ext, fileList)) {
				add += 1;
			}
			
			result = result + "_" + String.valueOf(add);
		}
		
		return result + "." + ext;
!!!346370.java!!!	updateGroupProperty() : void
		
		HashMap< String, TreeSet< ValueString > > members = new HashMap< String, TreeSet< ValueString > >();
		
		for (Iterator< String > it = hostData.keySet().iterator(); it.hasNext(); ) {
			members.put(it.next(), new TreeSet< ValueString >());
		}
		
		for (Iterator< HostGroup > it = groupData.values().iterator(); it.hasNext(); ) {
			HostGroup group = it.next();
			
			for (Iterator< String > jt = group.iterator(); jt.hasNext(); ) {
				String host = jt.next();
				
				members.get(host).add(new ValueString(group.getName()));
			}
		}
		
		for (Iterator< HostInfo > it = hostData.values().iterator(); it.hasNext(); ) {
			HostInfo current = it.next();
			
			current.setMemberOf(members.get(current.getHostName()));
		}
!!!346498.java!!!	buildAliasTable(inout host : HostInfo) : void
		
		ArrayList< SoftwareAlias > alias = new ArrayList< SoftwareAlias >();
		
		// for every product...
		for (int i = 0; i < host.getProductCount(); ++i) {
			Product product = host.getProduct(i);
			String aliasName = null;
			String productName = null;
			String productVersion = null;
			String productVendor = null;
			
			// ...test every alias definition
			for (SoftwareAliasDefinition ad: aliases) {
				if (ad.getOsRestriction() != null) {
					boolean osTest = false;
					
					try {
						osTest = host.getOperatingSystem().test(ad.getOsRestriction(), true);
					} catch (Exception e) {
						// os test failed, skip current alias
						continue;
					}
					
					if (!osTest) {
						// host does not have correct OS, skip this alias
						continue;
					}
				}
				
				boolean match = false;
				
				try {
					match = product.test(ad.getAppRestriction(), false);
				} catch (Exception e) {
					match = false;
				}
				
				if (match) {
					try {
						aliasName = evaluateStringWithPropertyVariables(ad.getAliasName(), product);
						productName = evaluateStringWithPropertyVariables(ad.getResultName(), product);
						productVendor = evaluateStringWithPropertyVariables(ad.getResultVendor(), product);
						productVersion = evaluateStringWithPropertyVariables(ad.getResultVersion(), product);
					} catch (IllegalArgumentException e) {
						logger.logError("Error building alias \"" + ad.getAliasName()
								+ "\", message: " + e.getMessage());
						continue;
					}
					alias.add(new SoftwareAlias(aliasName, productName, productVersion, productVendor));
				}
			}
		}
		
		// now all aliases to the host
		for (SoftwareAlias a: alias) {
			try {
				host.addAlias(a);
			} catch (Exception e) {
				throw new HostDatabaseException("Unable to add alias to the list", e);
			}
		}
!!!346626.java!!!	evaluateStringWithPropertyVariables(in s : String, inout pt : PropertyTreeReadInterface) : String
		
		return substitutor.parseString(s, new PropertyTreeDataProvider(pt));
