class SubstituteVariableValues
!!!251266.java!!!	SubstituteVariableValues()
		
		syntaxChecker = new RegexpVariableNameSyntaxChecker(DEFAULT_VARIABLE_SYNTAX_REGEXP);
		tokenizer = new StringTokenizer("\\${}");
!!!251394.java!!!	SubstituteVariableValues(in variableSyntaxRegexp : String)

		if (variableSyntaxRegexp == null) {
			
			throw new IllegalArgumentException("null variable syntax regular expression is not allowed.");
		}
		
		if (variableSyntaxRegexp.length() == 0) {
			
			throw new IllegalArgumentException("Empty variable syntax regular expression is not allowed.");
		}
		
		syntaxChecker = new RegexpVariableNameSyntaxChecker(variableSyntaxRegexp);
		tokenizer = new StringTokenizer("\\${}");
!!!251522.java!!!	SubstituteVariableValues(inout syntaxChecker : VariableNameSyntaxCheckerInterface)
		
		if (syntaxChecker == null) {
			throw new IllegalArgumentException("null syntax checker is not allowed.");
		}
		
		this.syntaxChecker = syntaxChecker;
!!!251650.java!!!	parseString(in input : String, inout valueProvider : VariableValueProviderInterface) : String

		StringBuilder resultBuilder = new StringBuilder(input.length());

		List< StringTokenizer.Token > tokens = tokenizer.tokenize(input);
		int state = 0;
		String currentVariableName = "";
		int currentVariableStart = 0;
		
		for (StringTokenizer.Token token: tokens) {
			
			if (token.isDelimiter()) {
				char tokenChar = ((StringTokenizer.DelimiterToken) token).delimiterChar();
				
				switch (state) {
					case 0: // we have delimiter after string token or at the begining of the input
						switch (tokenChar) {
							case '$':
								state = 1;
								break;
								
							case '\\':
								state = 2;
								break;
								
							case '{':
							case '}':
								throw new IllegalArgumentException("Unexpected token \"" 
										+ tokenChar + "\" at position " + token.getPosition() + ".");
								
							default:
								throw new IllegalArgumentException("Internal error.");
						}
						break;
						
					case 1: // variable declaration start
						switch (tokenChar) {
							case '{': // next token has to be variable declaration
								state = 3;
								break;
								
							default:
								throw new IllegalArgumentException("Unexpected token \""
										+ tokenChar + "\" at position " + token.getPosition() + "."
										+ " \"{\" expected.");
						}
						break;
						
					case 2: // we are in the escape sequence, append character we are escaping
						resultBuilder.append(tokenChar);
						state = 0;
						break;
						
					case 3:
						switch (tokenChar) {

							case '}': // closing brace of the name, not good
								throw new IllegalArgumentException("Empty variable name at position "
										+ (token.getPosition() - 2) + ".");
							
							default: // every other delimiter is also error, but it will not get its
								     // own exception message
								throw new IllegalArgumentException("Unexpected token at \""
										+ tokenChar + "\" at position " + token.getPosition()
										+ ". Variable name expected.");
						}

					case 4: // we expect closing curly thingy here
						switch (tokenChar) {
							
							case '}':
								// we have closing brace for the variable name
								// so get the name and query value provider for the value
								
								// but first, check syntax
								if (!syntaxChecker.checkName(currentVariableName)) {
									throw new IllegalArgumentException("Invalid variable declaration \""
											+ currentVariableName + "\" at position "
											+ currentVariableStart + ".");
								}

								T variableValue = valueProvider.getValue(currentVariableName);
								
								if (variableValue == null) {
									throw new IllegalArgumentException("Unknown variable \""
											+ currentVariableName + "\" at position " 
											+ currentVariableStart + ".");
								}
								
								resultBuilder.append(variableValue.toString());
								
								state = 0;
								break;
								
							default:
								throw new IllegalArgumentException("Unexpected token \"" 
										+ tokenChar + "\" at position " + token.getPosition()
										+ ". Closing \"}\" expected.");
						}
						
						break;
						
					default:
						throw new IllegalArgumentException("Internal error.");
				}
			} else {
				String tokenString = ((StringTokenizer.StringToken) token).getString();
				
				switch (state) {
					case 0: // string token
						resultBuilder.append(tokenString);
						state = 0;
						break;
					
					case 1: // after the $ sign, we expect { and not string token
						throw new IllegalArgumentException("Unexpected token at position "
								+ token.getPosition() + ". \"{\" expected.");
						
					case 2: // escape sequence, this means, we have unknown escape, we will leave it be
						resultBuilder.append('\\');
						resultBuilder.append(tokenString);
						state = 0;
						break;
						
					case 3: // this token has to be variable name
						
						// we will store it for later use
						currentVariableName = tokenString;
						currentVariableStart = token.getPosition() - 2;
						
						state = 4;
						break;

					default:
					case 4: // ok, so this is not cool
						throw new IllegalArgumentException("Internal error at position \""
								+ token.getPosition() + "\".");
				}
			}			
		}
		
		switch (state) {
			case 0:
				// this is ok
				break;
				
			case 1:
				throw new IllegalArgumentException("Unexpected end of input. Variable declaration expected.");
				
			case 2:
				throw new IllegalArgumentException("Unexpected end of input."
						+ " Second character of escape sequence expected.");
				
			case 3:
				throw new IllegalArgumentException("Unexpected end of input. Variable name expected.");
				
			default:
			case 4:
				throw new IllegalArgumentException("Unexpected end of input. Closing \"}\" expected.");
		}
		
		return resultBuilder.toString();
!!!251778.java!!!	parseString(in input : String, inout values : Map< String, T >) : String
		
		return parseString(input, new MapVariableValueProvider< T >(values));
