class SoftwareRepositoryImplementation
!!!616706.java!!!	SoftwareRepositoryImplementation()
		super();
		this.task = Task.getTaskHandle();
!!!616834.java!!!	getDataDir() : String
		return dataDir;
!!!616962.java!!!	getTempDir() : String
		return tempDir;
!!!617090.java!!!	getInstance() : SoftwareRepositoryImplementation
		if (instance == null) {
			 instance = new SoftwareRepositoryImplementation();
		}
		return instance;
!!!617218.java!!!	initialize(in dataDir : String, in tempDir : String) : void
		this.dataDir = dataDir;
		this.tempDir = tempDir;
		if (counterFileExists()) {
			logInfo("Counter file found - loading...");
			loadCounter();
			logInfo("Counter loaded OK.");
		}
		logInfo("Extracting metadata from packages...");
		extractMetadataFromPackages();
		logInfo("Metadata extracted and saved OK.");
!!!617346.java!!!	logInfo(in message : String) : void
		if (task != null) {
			task.logInfo(message);
		} else {
			System.out.println(message);
		}
!!!617474.java!!!	logError(in message : String) : void
		if (task != null) {
			task.logError(message);
		} else {
			System.err.println(message);
		}
!!!617602.java!!!	readXMLDocumentFromZippedFile(inout zipFile : ZipFile, in xmlFilename : String) : Document
		
		Document result = null;
		InputStream inputStream = null;
		try {
			inputStream = zipFile.getInputStream(zipFile.getEntry(xmlFilename));
			DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
			try {
				result = builder.parse(inputStream);
			} catch (SAXException e) {
				result = null;   
			}
		} finally {
			inputStream.close();
		}

		return result;
!!!617730.java!!!	getDocumentPackageType(inout document : Document) : PackageType
		AttributeHelper helper = PackageTypeAttributeHelper.getInstance();
		Element typeElement = getAttributeElementByName(document, "type");
		if (typeElement == null) {
			return null;
		}
		if (helper.validateInXML(typeElement) != null) {
			return null;
		}
		return ((PackageType) helper.readValueFromElement(typeElement));
!!!617858.java!!!	getAttributeElementByName(inout document : Document, in name : String) : Element
		NodeList list = document.getElementsByTagName(name);
		if (list.getLength() == 1) {
			return (Element) list.item(0);   
		} else {
			return null;
		}
!!!617986.java!!!	validateAttributeExiststenceAndValue(inout document : Document, inout info : AttributeInfo) : String
		Element attributeElement = getAttributeElementByName(document, info.getName());
		if (attributeElement == null) {
			return PACKAGE_METADATA_FILE + ": Missing <" + info.getName()
			  + "> element.";
		}
		String validationResult = info.getHelper().validateInXML(attributeElement);
		return validationResult != null
			? PACKAGE_METADATA_FILE + ": " + validationResult 
			: null;
!!!618114.java!!!	validateRequiredAttributesAndValues(inout document : Document, inout packageType : PackageType) : String
		/* Go through all metadata attributes and if the attribute is
		 * required for given package type, check its presence and validity
		 * of contained information.
		 */
		List<String> result = new LinkedList<String>();
		for (int i = 0; i < PackageMetadata.ATTRIBUTE_INFO.length; i++) {
			AttributeInfo attributeInfo = PackageMetadata.ATTRIBUTE_INFO[i];
			if (attributeInfo.getRequired().contains(packageType)) {
				String errorMessage = validateAttributeExiststenceAndValue(document, attributeInfo);
				if (errorMessage != null) {
					result.add(errorMessage);
				}
			}
		}
		return result.toArray(new String[result.size()]);
!!!618242.java!!!	validatePackageMetadataFile(inout zipFile : ZipFile) : String
		Document document = readXMLDocumentFromZippedFile(zipFile, PACKAGE_METADATA_FILE);
		
		/* Check that document is not null. If it is, it means it isn't valid XML
		 * file, so report error.
		 */
		if (document == null) {
			return new String[] { PACKAGE_METADATA_FILE + ": Not valid XML file." };
		}
		
		Element documentElement = document.getDocumentElement();
		
		/* Check that root element is <package>. */
		if (!documentElement.getNodeName().equals("package")) {
			return new String[] { PACKAGE_METADATA_FILE + ": Root element must be <package>." };
		}
		
		/* Determine package type. */
		PackageType packageType = getDocumentPackageType(document);
		if (packageType == null) {
			return new String[] { PACKAGE_METADATA_FILE + ": Missing <type> element or invalid value of element <type>." };
		}

		/* Check attributes for given package type. */ 
		return validateRequiredAttributesAndValues(document, packageType);
!!!618370.java!!!	validatePackageConfigFile(inout zipFile : ZipFile) : String
		Document document = readXMLDocumentFromZippedFile(zipFile, PACKAGE_CONFIG_FILE);

		/* Check that document is not null. If it is, it means it isn't valid XML
		 * file, so report error.
		 */
		if (document == null) {
			return new String[] { PACKAGE_CONFIG_FILE + ": Not valid XML file." };
		}
		
		Element documentElement = document.getDocumentElement();
		
		/* Check that root element is <packageConfiguration>. */
		if (!documentElement.getNodeName().equals("packageConfiguration")) {
			return new String[] { PACKAGE_CONFIG_FILE + ": Root element must be <packageConfiguration>." };
		}

		/* Check presence of the <java> element. */ 
		NodeList javaElements = documentElement.getElementsByTagName("java");
		Element javaElement;
		if (javaElements.getLength() == 1) {
			javaElement = (Element) javaElements.item(0);   
		} else {
			return new String[] { PACKAGE_CONFIG_FILE + ": There must be one <java> element present." }; 
		}	

		/* Check presence of the <java> element's attributes. */
		if (!javaElement.hasAttribute("classPath")) {
			return new String[] { PACKAGE_CONFIG_FILE + ": Missing \"classPath\" attribute of the <java> element." };
		}
		if (!javaElement.hasAttribute("mainClass")) {
			return new String[] { PACKAGE_CONFIG_FILE + ": Missing \"mainClass\" attribute of the <java> element." };
		}
		
		/* We've passed all the tests now. */
		return new String[0];
!!!618498.java!!!	validatePackage(in filename : String) : String
		
		/* Open the package file. In fact, it is a ZIP file. */
		ZipFile zipFile; 
		try {
			zipFile = new ZipFile(filename);
		} catch (ZipException e) {
			return new String[] { "Error reading package file." };
		}
        
		try {
			List<String> result = new LinkedList<String>();
			
			/* Check, if directory "files" and file "metadata.xml" are present. */
			ZipEntry filesDirEntry = zipFile.getEntry(PACKAGE_FILES_DIR + "/");
			if (filesDirEntry == null) {
				result.add("Missing \"" + PACKAGE_FILES_DIR + "\" directory.");
			}
			ZipEntry metadataFileEntry = zipFile.getEntry(PACKAGE_METADATA_FILE);
			if (metadataFileEntry == null) {
				result.add("Missing \"" + PACKAGE_METADATA_FILE + "\" file.");
			}
			if (!result.isEmpty()) {
				return result.toArray(new String[result.size()]);
			}
			
			/* Check the validity of "metadata.xml". */
			result = Arrays.asList(validatePackageMetadataFile(zipFile));
			if (!result.isEmpty()) {
				return result.toArray(new String[result.size()]);
			}
			
			/* Now we know he have valid metadata. We read it and determine the
			 * package type. If the package type is "task", we also check if the
			 * "config.xml" exists and is valid.
			 * 
			 * Note that reading the whole metadata at this point is suboptimal,
			 * but this is no big deal, because the file is small. We may optimize
			 * this later, if necessary.
			 */
			PackageMetadata metadata = readPackageMetadata(filename);
			if (metadata.getType().equals(PackageType.TASK)) {
				ZipEntry configFileEntry = zipFile.getEntry(PACKAGE_CONFIG_FILE);
				if (configFileEntry == null) {
					return new String[] { "Missing \"" + PACKAGE_CONFIG_FILE + "\" file." };
				}
				return validatePackageConfigFile(zipFile);
			}
		} finally {
			zipFile.close();
		}
		
		/* We've passed all the tests now. */
		return new String[0];
!!!618626.java!!!	readPackageMetadata(in filename : String) : PackageMetadata
 
		/* Open the package file. In fact, it is a ZIP file. */
		ZipFile zipFile = new ZipFile(filename);
		try {
			/* Extract only file name (without path). */
			int separatorPos = filename.lastIndexOf(File.separator);
			filename = filename.substring(separatorPos + 1);
			
			/* Read XML document from the "metadata.xml" and extract metadata attributes. */
			Document document = readXMLDocumentFromZippedFile(zipFile, PACKAGE_METADATA_FILE);
			
			Element nameElement = getAttributeElementByName(document, "name"); 
			Element versionElement = getAttributeElementByName(document, "version"); 
			Element hardwarePlatformsElement = getAttributeElementByName(document, "hardwarePlatforms"); 
			Element softwarePlatformsElement = getAttributeElementByName(document, "softwarePlatforms"); 
			Element typeElement = getAttributeElementByName(document, "type"); 
			Element humanNameElement = getAttributeElementByName(document, "humanName"); 
			Element downloadURLElement = getAttributeElementByName(document, "downloadURL"); 
			Element downloadDateElement = getAttributeElementByName(document, "downloadDate"); 
			Element sourcePackageFilenameElement = getAttributeElementByName(document, "sourcePackageFilename");
			Element binaryIdentifierElement = getAttributeElementByName(document, "binaryIdentifier");
			Element buildConfigurationElement = getAttributeElementByName(document, "buildConfiguration");
            
			return new PackageMetadata(
					filename,
					new File(filename).length(),
					(String) StringAttributeHelper.getInstance().readValueFromElement(
							nameElement
					),
					(Version) VersionAttributeHelper.getInstance().readValueFromElement(
							versionElement
					),
					hardwarePlatformsElement != null
					? (ArrayList) ArrayListAttributeHelper.getInstance().readValueFromElement(
							hardwarePlatformsElement
					)
					: new ArrayList(),
					softwarePlatformsElement != null
					? (ArrayList) ArrayListAttributeHelper.getInstance().readValueFromElement(
							softwarePlatformsElement
					)
					: new ArrayList(),
					(PackageType) PackageTypeAttributeHelper.getInstance().readValueFromElement(
							typeElement
					),
					(String) StringAttributeHelper.getInstance().readValueFromElement(
							humanNameElement
					),
					downloadURLElement != null
					? (String) StringAttributeHelper.getInstance().readValueFromElement(
							downloadURLElement
					)
					: null,
					downloadDateElement != null
					? (Date) DateAttributeHelper.getInstance().readValueFromElement(
							downloadDateElement
					)
					: new Date(0),
					sourcePackageFilenameElement != null
					? (String) StringAttributeHelper.getInstance().readValueFromElement(
							sourcePackageFilenameElement
					)
					: null,
					binaryIdentifierElement != null
					? (String) StringAttributeHelper.getInstance().readValueFromElement(
							binaryIdentifierElement
					)
					: null,
					buildConfigurationElement != null
					? (String) StringAttributeHelper.getInstance().readValueFromElement(
							buildConfigurationElement
					)
					: null
			);       
		} finally {
			zipFile.close();
		}
!!!618754.java!!!	addMetadata(inout metadata : PackageMetadata) : void
		synchronized (packageMetadata) {
			packageMetadata.add(metadata);
			saveCounter();
		}
!!!618882.java!!!	deleteMetadataForFilename(in filename : String) : void
		synchronized (packageMetadata) {
			/* Firstly go through the metadata and determine if there is anything
			 * to delete.
			 */
			int index = -1;
			for (int i = 0; i < packageMetadata.size(); i++) {
				if (packageMetadata.get(i).getFilename().equals(filename)) {
					index = i;
					break;
				}
			}
			
			/* If no item to delete was found, blame the caller. */
			if (index == -1) {
				throw new IllegalArgumentException("Package \"" + "\" doesn't exist.");   
			}
			
			/* Do the actual deletion. */
			packageMetadata.remove(index);
		}
!!!619010.java!!!	createPackageFilename(inout metadata : PackageMetadata) : String
		/* Concatenate all hardware platforms into "+"-separated string. */
		String hardwarePlatforms = "";
		ListIterator hardwarePlatformsIterator = metadata.getHardwarePlatforms().listIterator();
		while (hardwarePlatformsIterator.hasNext()) {
			if (hardwarePlatformsIterator.nextIndex() > 0) {
				hardwarePlatforms += "+";
			}
			hardwarePlatforms += hardwarePlatformsIterator.next();
		}
		
		/* Concatenate all software platforms into "+"-separated string. */
		String softwarePlatforms = "";
		ListIterator softwarePlatformsIterator = metadata.getSoftwarePlatforms().listIterator();
		while (softwarePlatformsIterator.hasNext()) {
			if (softwarePlatformsIterator.nextIndex() > 0) {
				softwarePlatforms += "+";
			}
			softwarePlatforms += softwarePlatformsIterator.next();
		}
		
		/* Create the package name. */
		synchronized (this) {
			String result = metadata.getName() + "-"
				+ hardwarePlatforms + "-" 
				+ softwarePlatforms + "-"
				+ metadata.getType().getSuffix() + "."
				+ autoIncrementedCounter + PACKAGE_FILE_SUFFIX;
			autoIncrementedCounter++;
			return result;
		}
!!!619138.java!!!	extractMetadataFromPackages() : void
		synchronized (packageMetadata) {
			packageMetadata.clear();
			
			/* Java's ugly and verbose way to say "get me files like *.bpk"... */  	
			File[] packages = new File(dataDir).listFiles(new FilenameFilter() {
				public boolean accept(File dir, String name) {
					return (name.endsWith(PACKAGE_FILE_SUFFIX));
				}
			});
		
			for (File packageFile: packages) {
				try {
					if (validatePackage(packageFile.getPath()).length == 0) {
						packageMetadata.add(readPackageMetadata(packageFile.getPath()));
						logInfo(packageFile.getName() + ": metadata indexed.");
					} else {
						logError(packageFile.getName() + ": invalid package.");
					}
				} catch (IOException e) {
					/* Ignore - if the package reading fails, we just don't care about that file. */ 
					logError(packageFile.getName() + ": exception while reading: " + e.toString());
				} catch (ParserConfigurationException e) {
					/* Ignore - if the package reading fails, we just don't care about that file. */ 
					logError(packageFile.getName() + ": exception while reading: " + e.toString());
				} catch (FactoryConfigurationError e) {
					/* Ignore - if the package reading fails, we just don't care about that file. */ 
					logError(packageFile.getName() + ": exception while reading: " + e.toString());
				}
			}
			saveCounter();
		}
!!!621570.java!!!	beginPackageDownload(in filename : String, inout ip : InetAddress, in port : int) : DownloadHandle
		File packageFile = new File(dataDir + File.separator + filename);
		if (!packageFile.exists()) {
			throw new IllegalArgumentException("Package \"" + filename + "\" doesn't exist.");
		}
		
		DownloadHandle handle = DownloadHandle.createDownloadHandle();
		PackageDownloadThread downloader = new PackageDownloadThread(handle, filename, ip, port);
		downloader.start();
		return handle;
!!!621698.java!!!	getPackageDownloadStatus(inout handle : DownloadHandle) : DownloadStatus
		DownloadStatus result = downloadStatuses.get(handle);
		if (result != null) {
			return result;
		} else {
			throw new IllegalArgumentException("Invalid handle.");
		}
!!!621826.java!!!	endPackageDownload(inout handle : DownloadHandle) : void
		downloadStatuses.remove(handle);
!!!621954.java!!!	beginPackageUpload(inout ip : InetAddress, in port : int) : UploadHandle
		UploadHandle handle = UploadHandle.createUploadHandle();
		PackageUploadThread uploader = new PackageUploadThread(handle, ip, port);
		uploader.start();
		return handle;
!!!622082.java!!!	getPackageUploadStatus(inout handle : UploadHandle) : UploadStatus
		UploadStatus result = uploadStatuses.get(handle);
		if (result != null) {
			return result;
		} else {
			throw new IllegalArgumentException("Invalid handle.");
		}
!!!622210.java!!!	getRejectedPackageUploadErrorMessages(inout handle : UploadHandle) : String
		UploadStatus uploadStatus = uploadStatuses.get(handle);
		if (uploadStatus == null) {
			throw new IllegalArgumentException("Invalid handle.");
		}
		if (uploadStatus != UploadStatus.REJECTED) {
			throw new IllegalStateException("Package not rejected.");
		}
		return uploadErrorMessages.get(handle);
!!!622338.java!!!	endPackageUpload(inout handle : UploadHandle) : void
		uploadStatuses.remove(handle);
		uploadErrorMessages.remove(handle);
!!!622466.java!!!	deletePackage(in filename : String) : boolean
		File packageFile = new File(dataDir + File.separator + filename);
		if (!packageFile.exists()) {
			return false;
		}
		try {
			deleteMetadataForFilename(filename);
		} catch (IllegalArgumentException e) {
			return false;
		}
		if (packageFile.delete()) {
			logInfo("Successfully deleted package \"" + packageFile.getPath() + "\".");
			return true;
		} else {
			logError("Error deleting package \"" + packageFile.getPath() + "\".");
			return true;
		}
!!!622594.java!!!	queryPackages(inout callback : PackageQueryCallbackInterface) : PackageMetadata
		ArrayList<PackageMetadata> resultList = new ArrayList<PackageMetadata>();
		for (int i = 0; i < packageMetadata.size(); i++) {
			PackageMetadata metadata = packageMetadata.get(i);
			if (callback.match(metadata)) {
				resultList.add(metadata);  
			}
		}
		PackageMetadata[] result = new PackageMetadata[resultList.size()];
		return (PackageMetadata[]) resultList.toArray(result);
!!!622722.java!!!	counterFileExists() : boolean
		File hashFile = new File(dataDir + File.separator + COUNTER_FILE);
		return hashFile.exists();
!!!622850.java!!!	loadCounter() : void
		ObjectInputStream inputStream = new ObjectInputStream(
				new FileInputStream(dataDir + File.separator + COUNTER_FILE)
		);
		try {
			autoIncrementedCounter = inputStream.readLong();
		} finally { 
			inputStream.close();
		}
!!!622978.java!!!	saveCounter() : void
		ObjectOutputStream outputStream = new ObjectOutputStream(
				new FileOutputStream(dataDir + File.separator + COUNTER_FILE)
		);
		try {
			outputStream.writeLong(autoIncrementedCounter);
		} finally {
			outputStream.close();
		}
