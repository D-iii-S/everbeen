class LoadFileParser
!!!415746.java!!!	LoadFileParser(in fileName : String, inout append : boolean, inout fjg : Class< T >)
		
		this.fjg = fjg;
		
		MiscUtils.verifyStringParameterBoth(fileName, "fileName");
		MiscUtils.verifyParameterIsNotNull(fjg, "fjg");
		
		// Now verify that we have correct class.
		try {
			T x = this.fjg.newInstance();
			
			nodeId = x.getChunkID();
		} catch (Exception e) {
			throw new InvalidArgumentException("Invalid class.", e);
		}
		
		File f = new File(fileName);
		
		if (append) {
			dataFile = new RandomAccessFile(f, "rws");
			channel = dataFile.getChannel();
			dataFile.seek(dataFile.length());
		} else {
			dataFile = new RandomAccessFile(f, "r");
			channel = dataFile.getChannel().position(0);
		}

		headerBuffer = ByteBuffer.allocateDirect(HEADER_BUFFER_SIZE);
		footerBuffer = ByteBuffer.allocateDirect(FOOTER_BUFFER_SIZE);
!!!415874.java!!!	LoadFileParser(inout file : File, inout append : boolean, inout fjg : Class< T >)
		
		this.fjg = fjg;
		
		MiscUtils.verifyParameterIsNotNull(file, "file");
		MiscUtils.verifyParameterIsNotNull(fjg, "fjg");
		
		// Now verify that we have correct class.
		try {
			T x = this.fjg.newInstance();
			
			nodeId = x.getChunkID();
		} catch (Exception e) {
			throw new InvalidArgumentException("Invalid class.", e);
		}
		
		if (append) {
			dataFile = new RandomAccessFile(file, "rws");
			channel = dataFile.getChannel();
			dataFile.seek(dataFile.length());
		} else {
			dataFile = new RandomAccessFile(file, "r");
			channel = dataFile.getChannel().position(0);
		}

		headerBuffer = ByteBuffer.allocateDirect(HEADER_BUFFER_SIZE);
		footerBuffer = ByteBuffer.allocateDirect(FOOTER_BUFFER_SIZE);
!!!416002.java!!!	getNext() : T

		if (channel == null) {
			throw new IllegalOperationException("Unable to read from the closed file.");
		}
		
		// This will cache new entry if needed.
		if (hasNext()) {
			T result = next;
			next = null;
			
			return result;
		} else {
			throw new IOException("End of file reached.");
		}
!!!416130.java!!!	getNext(in n : int) : List< T >

		if (channel == null) {
			throw new IllegalOperationException("Unable to read from the closed file.");
		}
		
		List< T > result = new ArrayList< T >();
		
		for (int i = 0; i < 0; ++i) {
			result.add(getNext());
		}
		
		return result;
!!!416258.java!!!	hasNext() : boolean
	
		if (channel == null) {
			throw new IllegalOperationException("Unable to read from the closed file.");
		}
		
		if (next == null) {
			return getNextNode();
		} else {
			return true;
		}
		
!!!416386.java!!!	skip(in amount : int) : void
		
		if (channel == null) {
			throw new IllegalOperationException("Unable to read from the closed file.");
		}
		
		if (amount < 0) {
			throw new InvalidArgumentException("Unable to skip negative amount of nodes.");
		}

		for (int i = 0; i < amount; ++i) {
			getNext();
		}
!!!416514.java!!!	append(inout value : T) : void
		
		if (channel == null) {
			throw new IllegalOperationException("Unable to write to the closed file.");
		}
		
		MiscUtils.verifyParameterIsNotNull(value, "value");
		
		if ((dataBuffer == null)
			|| (dataBuffer.capacity() < value.getDataSize() + HEADER_BUFFER_SIZE + FOOTER_BUFFER_SIZE)) {
			dataBuffer = ByteBuffer.allocateDirect(value.getDataSize()
			                                       + HEADER_BUFFER_SIZE
			                                       + FOOTER_BUFFER_SIZE);
		}

		dataBuffer.clear();
		
		dataBuffer.put(value.getChunkID());
		dataBuffer.putInt(value.getDataSize());

		try {
			value.save(dataBuffer);
		} catch (OutputWriteException e) {
			throw new IOException("Unable to write data to the buffer.");
		}
		
		dataBuffer.put((byte) -value.getChunkID());
		
		dataBuffer.flip();
		
		try {
			channel.write(dataBuffer);
		} catch (Exception e) {
			throw new IOException(e.getMessage());
		}
!!!416642.java!!!	append(inout value : T) : void
		
		MiscUtils.verifyParameterIsNotNull(value, "value");

		for (T x: value) {
			append(x);
		}
!!!416770.java!!!	append(inout value : List< T >) : void
		
		MiscUtils.verifyParameterIsNotNull(value, "value");

		for (T x: value) {
			append(x);
		}
!!!416898.java!!!	close() : void
		
		channel.close();
		channel = null;
!!!417026.java!!!	finalize() : void
		
		if (channel != null) {
			try {
				channel.close();
			} catch (Exception e) {
				// Do nothing.
			}
		}
		
		super.finalize();
!!!417154.java!!!	getPosition() : long
		
		return dataFile.getFilePointer();
!!!417282.java!!!	seek(in position : long) : void

		MiscUtils.verifyIntParameterGEZero(position, "position");
		
		dataFile.seek(position);
!!!417410.java!!!	getNextNode() : boolean

		next = null;
		
		// Read node's header data from file. 
		headerBuffer.clear();
		int headerBytes = 0;
		
		try {
			headerBytes = channel.read(headerBuffer);
		} catch (Exception e) {
			throw new IOException("Error reading data from file.");
		}
		
		if (headerBytes == -1) {
			return false;
		}
		
		if (headerBytes < HEADER_BUFFER_SIZE) {
			throw new InputParseException("Unexpected end of file.");
		}
		
		headerBuffer.rewind();
		
		// Parse header from file.
		byte currentId;
		int dataLength;
		
		try {
			currentId = headerBuffer.get();
			dataLength = headerBuffer.getInt();
		} catch (Exception e) {
			throw new InputParseException("Error reading data.", e);
		}
		
		if (currentId != nodeId) {
			throw new InputParseException("Invalid node identification. Found \"" + currentId
					+ "\", expected \"" + nodeId + "\".");
		}
		
		if (dataLength < 0) {
			throw new InputParseException("Invalid node's data size: \"" + dataLength + "\".");
		}

		// Allocate new buffer if necessary.
		if ((dataBuffer == null) || (dataBuffer.capacity() < dataLength)) {
			dataBuffer = ByteBuffer.allocateDirect(dataLength);
		}

		// Read data from file to buffer and rewind buffer to the beginning.
		dataBuffer.clear();
		dataBuffer.limit(dataLength);
		int dataBytes;
		try {
			dataBytes = channel.read(dataBuffer);
		} catch (Exception e) {
			throw new IOException("Error reading data from file.");
		}
		if (dataBytes < dataLength) {
			throw new InputParseException("Unable to read data from file.");
		}
		dataBuffer.rewind();

		// Create new instance of the type we are reading from the file.
		try {
			next = fjg.newInstance();
		} catch (Exception e) {
			// This should never happen, since we checked class in ctor.
			throw new RuntimeException("Unable to create new instance of node.", e);
		}
		
		// Now call load method on the target object.
		next.load(dataBuffer);

		// And finally read footer of the node and verify end mark.
		footerBuffer.clear();
		int footerBytes;
		try {
			footerBytes = channel.read(footerBuffer);
		} catch (Exception e) {
			throw new IOException("Unable to read data.");
		}
		
		if (footerBytes < FOOTER_BUFFER_SIZE) {
			throw new InputParseException("Unexpected end of file.");
		}
		footerBuffer.rewind();
		
		try {
			byte endId = footerBuffer.get();
			
			if (endId != (byte) -nodeId) {
				throw new InputParseException("Invalid end mark of the node. Found \"" + endId
						+ "\", expected value is \"" + (-nodeId) + "\".");
			}
		} catch (BufferUnderflowException e) {
			throw new IOException("Error reading data.");
		}
		
		return true;
