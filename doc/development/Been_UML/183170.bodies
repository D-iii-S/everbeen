class TaskProcessExecutor
!!!484610.java!!!	setProcessKilledFromOutside(inout processKilledFromOutside : boolean) : void
			this.processKilledFromOutside = processKilledFromOutside;
!!!484738.java!!!	TaskProcessExecutor(in stdoutFile : String, in stderrFile : String, inout commandAndParams : List<String>)
			this.stdoutFile = stdoutFile;
			this.stderrFile = stderrFile;
			this.commandAndParams = commandAndParams;
!!!484866.java!!!	execute() : void
			try {
				/* The process working directory must be set to taskDirectory, so the
				 * classpaths work. More specifically, Benchmark Manager breaks if it
				 * is set to different directory.
				 */
				process = Runtime.getRuntime().exec(
					commandAndParams.toArray(new String[commandAndParams.size()]),
					null,
					new File(taskDirectory) 
				);
			} catch (IOException e) {
				System.err.println("Error executing task process: " + e.getMessage());
				System.exit(1);
			}
!!!484994.java!!!	maybeStartLoadMonitorDetailedMode(in runCount : int) : void
			if (measureDetailedLoad) {
				LoadMonitorInterface loadMonitor = hostRuntime.getLoadMonitor();
				try {
					if (taskDescriptor.getDetailedLoadInterval() != 0) {
						loadMonitor.startDetailedMode(
							taskDescriptor.getContextId(),
							taskDescriptor.getTaskTid(),
							taskDescriptor.getDetailedLoadInterval()
						);
					} else {
						loadMonitor.startDetailedMode(
							taskDescriptor.getContextId(),
							taskDescriptor.getTaskTid()
						);
					}
				} catch (IllegalOperationException e) {
					throw new AssertionError("Invalid Load Monitor mode.");
				} catch (LoadMonitorException e) {
					System.err.println(e.getMessage());
					System.exit(1);
				} catch (RemoteException e) {
					throw new AssertionError("Local call should not fail.");
				}
			}
!!!485122.java!!!	maybeStopLoadMonitorDetailedMode() : void
			if (measureDetailedLoad) {
				try {
					hostRuntime.getLoadMonitor().stopDetailedMode();
				} catch (IllegalOperationException e) {
					throw new AssertionError("Invalid Load Monitor mode.");
				} catch (LoadMonitorException e) {
					System.err.println(e.getMessage());
					System.exit(1);
				} catch (RemoteException e) {
					throw new AssertionError("Local call should not fail.");
				}
			}
!!!485250.java!!!	attachOutputProcessors() : void
			new ProcessOutputProcessor(
				process.getInputStream(),
				stdoutFile,
				OutputType.STANDARD,
				taskDescriptor.getTaskExclusive()
			).start();
			new ProcessOutputProcessor(
				process.getErrorStream(),
				stderrFile,
				OutputType.ERROR,
				taskDescriptor.getTaskExclusive()
			).start();
!!!485634.java!!!	waitForProcess() : void
			processTimedOut = false;
			processKilledFromOutside = false;
			long timeout = taskDescriptor.getTimeoutRun();
			Thread killer = null;
			if (timeout != 0) {
				killer = new TaskProcessKiller(timeout);
				killer.start();
			}
			
			try {
				process.waitFor();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			if (killer != null && !processTimedOut) {
				killer.interrupt();
			}
!!!485762.java!!!	notifyHostRuntime() : void
			try {
				/* Following calls must be in correct order. Inside the call of the
				 * taskReachedState method, the Task Manager may decide to close
				 * context that contains this task and call
				 * HostRuntimeInterface.closeContext method. But if the calls are not
				 * ordered properly, the Host Runtime will not yet be notified about the
				 * task's end (the notification happens in notifyTaskFinished call) and
				 * refuse to close the context (throwing IllegalArgumentException). This
				 * would be a race condition. 
				 */
				hostRuntime.notifyTaskFinished(TaskImplementation.this);
				hostRuntime.getHostRuntimesPort().taskReachedState(
					taskDescriptor.getTaskTid(),
					taskDescriptor.getContextId(),
					processKilledFromOutside ? TaskState.ABORTED : TaskState.FINISHED);
			} catch (RemoteException e) {
				System.err.println("Error executing remote call from the task to the "
					+ "Task Manager.");
				System.exit(1);
			}
!!!485890.java!!!	sendLogs() : void
			for (LogRecord logRecord: logs) {
				try {
					hostRuntime.getHostRuntimesPort().log(
						taskDescriptor.getContextId(),
						taskDescriptor.getTaskTid(),
						logRecord.level,
						logRecord.timestamp,
						logRecord.message
					);
				} catch (RemoteException e) {
					System.err.println("Error executing remote call from the task to the "
							+ "Task Manager.");
					return;
				}
			}
!!!486018.java!!!	sendOutput(in inputFile : String, inout outputType : OutputType) : void
			InputStream inputStream = null;

			try {
				inputStream = new BufferedInputStream(new FileInputStream(inputFile));
			} catch (FileNotFoundException e) {
				System.err.println(e.getMessage());
				return;
			}
			
			try {
				try {
					byte[] buffer = new byte[BUFFER_SIZE];
					int bytesRead;
					while ((bytesRead = inputStream.read(buffer)) != -1) {
						try {
							switch (outputType) {
								case STANDARD:
									hostRuntime.getHostRuntimesPort().addStandardOutput(
											taskDescriptor.getContextId(), 
											taskDescriptor.getTaskTid(),
											new String(buffer, 0, bytesRead)
									);
									break;
								case ERROR:
									hostRuntime.getHostRuntimesPort().addErrorOutput(
											taskDescriptor.getContextId(), 
											taskDescriptor.getTaskTid(),
											new String(buffer, 0, bytesRead)
									);
								default:
									break;
							} 
						} catch (LogStorageException e) {
							System.err.println("Log storage error: " + e.getMessage());
							return;
						}
					}
				} finally {
					inputStream.close();
				}
			} catch (RemoteException e) {
				System.err.println("Error executing remote call from the task to the "
					+ "Task Manager.");
			} catch (IOException e) {
				System.err.println("Error sending task output: " + e.getMessage());
			}
!!!486146.java!!!	sendLogAndOutputIfNeeded() : void
			if (taskDescriptor.getTaskExclusive() != TaskExclusivity.NON_EXCLUSIVE) {
				sendLogs();
				sendOutput(stdoutFile, OutputType.STANDARD);
				sendOutput(stderrFile, OutputType.STANDARD);
			}
!!!486274.java!!!	signalCheckPoint(in name : String, inout value : Serializable) : void
			CheckPoint taskStartedCheckPoint = new CheckPoint(
				taskDescriptor.getTaskTid(),
				taskDescriptor.getContextId(),
				name,
				value
			);
			taskStartedCheckPoint.setHostName(taskDescriptor.getHostRuntimesName()[0]);
			try {
				hostRuntime.getHostRuntimesPort().checkPointReached(taskStartedCheckPoint);
			} catch (RemoteException e) {
				System.err.println("Error executing remote call from the task to the "
					+ "Task Manager.");
				System.exit(1);
			}
!!!486402.java!!!	cleanDirectory(in dir : String) : void
			try {
				Delete.deleteDirectory(dir);
			} catch (AntTaskException e) {
				System.err.println(e.getMessage());
				System.exit(1);
			}
			if (!new File(dir).mkdir()) {
				System.err.println("Can not create directory \"" + dir + "\".");
				System.exit(1);
			}
!!!486530.java!!!	run() : void
			int runCount = 0;
			boolean taskSuccessfull;
			boolean taskCanBeRestarted;
			do {
				execute();
				if (runCount != 0) {
					maybeStopLoadMonitorDetailedMode();
				}
				maybeStartLoadMonitorDetailedMode(runCount);
				attachOutputProcessors();
				if (runCount == 0) {
					writeMessage("Started.");
					signalCheckPoint(Task.CHECKPOINT_NAME_STARTED, null);
				} else {
					writeMessage("Restarted.");
					try {
						hostRuntime.getHostRuntimesPort().taskRestarted(
							taskDescriptor.getTaskTid(),
							taskDescriptor.getContextId()
						);
					} catch (RemoteException e) {
						writeMessage("Notification of the Task Manager about restart failed.");
					}
				}
				waitForProcess();
				cleanDirectory(temporaryDirectory);
				cleanDirectory(taskDirectory);
				cleanDirectory(serviceDirectory);
				taskSuccessfull = process.exitValue() == 0
					&& !processTimedOut
					&& !processKilledFromOutside;
				taskCanBeRestarted = runCount < taskDescriptor.getRestartMax()
					&& !processKilledFromOutside; 
				runCount++;
			} while (!taskSuccessfull && taskCanBeRestarted);
			
			maybeStopLoadMonitorDetailedMode();
			/* Following two calls should be ordered properly, otherwise the Task
			 * Manager will consider the task finished before sending a checkpoint,
			 * resulting in a exception.
			 */
			if (!processKilledFromOutside) {
				signalCheckPoint(Task.CHECKPOINT_NAME_FINISHED, process.exitValue());
			}
			notifyHostRuntime();
			sendLogAndOutputIfNeeded();
			
			writeMessage("Stopped.");
