class PropertyTree
!!!323714.java!!!	PropertyTree(in name : String, inout parentObj : PropertyTreeInterface)
		
		objectName = name;
		localProperties = new HashMap< String, ValueCommonInterface >();
		childObjects = new HashMap< String, ArrayList< PropertyTreeInterface > >();
		objectIndex = 0;
		
		if (parentObj != null) {
			parentObj.addObject(this);
		}
		
		this.parent = parentObj;
		
		modificationCount = 1;
		resetModCount = 0;
		hashCacheModCount = 0;
		
		rehash();
!!!323842.java!!!	PropertyTree(in name : String)

		objectName = name;
		localProperties = new HashMap< String, ValueCommonInterface >();
		childObjects = new HashMap< String, ArrayList< PropertyTreeInterface > >();
		objectIndex = 0;
		parent = null;
		
		modificationCount = 1;
		resetModCount = 0;
		hashCacheModCount = 0;
		
		rehash();
!!!323970.java!!!	PropertyTree(inout node : Node)
		
		localProperties = new HashMap< String, ValueCommonInterface >();
		childObjects = new HashMap< String, ArrayList< PropertyTreeInterface > >();

		modificationCount = 1;
		resetModCount = 0;
		hashCacheModCount = 0;

		parseXMLNode(node);
!!!324098.java!!!	parseXMLNode(inout node : Node) : void
		
		localProperties.clear();
		childObjects.clear();

		objectName = XMLHelper.getAttributeValueByName("typeName", node);
		objectIndex = -1;
		modify();
		parent = null;
		
		Node objects = null;
		
		try {
			objects = XMLHelper.getSubNodeByName("objects", node);
		} catch (InputParseException e) {
			// do nothing, if such node does not exist, we have no sub-objects.
		}
		
		if (objects != null) {
			// now parse all child objects
			ArrayList< Node > subnodes = XMLHelper.getChildNodesByName(XML_NODE_NAME, objects);
			
			for (Node n: subnodes) {
				try {
					PropertyTree pt = new PropertyTree(n);
				
					addObject(pt);
				} catch (InputParseException e) {
					throw new InputParseException("Error parsing property tree data.", e);
				}
			}
		}
		
		Node properties = null;
		
		try {
			properties = XMLHelper.getSubNodeByName("properties", node);
		} catch (InputParseException e) {
			// do nothing, we have no local properties.
		}
		
		if (properties != null) {
			// parse all properties
			ArrayList< Node > subnodes = XMLHelper.getChildNodesByName(NameValuePair.XML_NODE_NAME, properties);
			
			for (Node n: subnodes) {
				try {
					NameValuePair p = new NameValuePair(n);
					
					addProperty(p);
				} catch (Exception e) {
					throw new InputParseException("Error parsing PropertyTree object \""
							+ objectName + "\".", e);
				}
			}
		}
		
		rehash();
!!!324226.java!!!	exportAsElement(inout document : Document) : Element
		
		Element element = document.createElement(XML_NODE_NAME);

		element.setAttribute("typeName", getTypeName());
		
		if (getObjectCount() > 0) {
			Element objects = document.createElement("objects");
			
			element.appendChild(objects);
		
			for (Iterator< PropertyTreeReadInterface > it = getObjectIterator(); it.hasNext(); ) {
				
				objects.appendChild(it.next().exportAsElement(document));
			}
		}
		
		if (this.localProperties.size() > 0) {
			Element properties = document.createElement("properties");
			
			element.appendChild(properties);
			
			for (Iterator< NameValuePair > it = getPropertyIterator(); it.hasNext(); ) {
				
				properties.appendChild(it.next().exportAsElement(document));
			}
		}
		
		return element;
!!!324354.java!!!	getXMLNodeName() : String
		
		return XML_NODE_NAME;
!!!324482.java!!!	isModified() : boolean
		
		if (modificationCount != resetModCount) {
			return true;
		}

		for (Iterator< PropertyTreeReadInterface > it = this.getObjectIterator(); it.hasNext(); ) {
			PropertyTree c = (PropertyTree) it.next();
			
			if (c.isModified()) {
				return true;
			}
		}
		
		return false;
!!!324610.java!!!	isModified(inout reset : boolean) : boolean
		
		// not the best possible way to do this, but it works...
		
		boolean result = isModified();
		
		if (result && reset) {
			for (Iterator< PropertyTreeReadInterface > it = this.getObjectIterator(); it.hasNext(); ) {
				PropertyTree c = (PropertyTree) it.next();

				c.reset();
			}
		}
		
		return result;
!!!324738.java!!!	reset(inout recursive : boolean) : void
		
		reset();
		
		if (recursive) {
			for (Iterator< PropertyTreeReadInterface > it = this.getObjectIterator(); it.hasNext(); ) {
				PropertyTree c = (PropertyTree) it.next();

				c.reset(true);
			}
		}
!!!324866.java!!!	getPropertyNames() : String

		String []result = new String[localProperties.keySet().size()];
		
		return localProperties.keySet().toArray(result);
!!!324994.java!!!	getObjectNames() : String
		
		String []result = new String[childObjects.keySet().size()];
		
		return childObjects.keySet().toArray(result);
!!!325122.java!!!	getPropertyValue(in propertyName : String) : ValueCommonInterface
		
		if (!isValidTypeName(propertyName)) {
			throw new InvalidArgumentException("Invalid property name \"" + propertyName + "\"");
		}
		
		if (localProperties.containsKey(propertyName)) {
			return localProperties.get(propertyName);
		} else {
			throw new ValueNotFoundException("Property \"" + propertyName + "\" not found in \""
					+ getName(true) + "\".");
		}
!!!325250.java!!!	getPropertyValue(in objectPath : String, in propertyName : String) : ValueCommonInterface
		
		if (!isValidObjectPath(objectPath)) {
			throw new InvalidArgumentException("Invalid object path \"" + objectPath + "\"");
		}
		
		// return local property if path is empty
		if (objectPath.length() == 0) {
			return getPropertyValue(propertyName);
		}
		
		return getObject(objectPath).getPropertyValue(propertyName);
!!!325378.java!!!	setPropertyValue(in propertyName : String, inout newValue : ValueCommonInterface) : ValueCommonInterface

		if (hasProperty(propertyName)) {
			modify();
			
			return localProperties.put(propertyName, newValue);
		} else {
			throw new ValueNotFoundException("Property \"" + propertyName + "\" not found in \""
					+ getName(true) + "\".");
		}
!!!325506.java!!!	setPropertyValue(inout property : NameValuePair) : ValueCommonInterface
		
		return setPropertyValue(property.getName(), property.getValue());
!!!325634.java!!!	addProperty(in propertyName : String, inout propValue : ValueCommonInterface) : void
		
		if (!isValidTypeName(propertyName)) {
			throw new InvalidArgumentException("Invalid property name \"" + propertyName + "\".");
		}
		
		if (hasProperty(propertyName)) {
			throw new InvalidArgumentException("Property \"" + propertyName + "\" already exists.");
		}
		
		localProperties.put(propertyName, propValue);
		
		modify();
!!!325762.java!!!	addProperty(inout property : NameValuePair) : void
		
		addProperty(property.getName(), property.getValue());
!!!325890.java!!!	putProperty(in propertyName : String, inout value : ValueCommonInterface) : ValueCommonInterface
		
		if (!isValidTypeName(propertyName)) {
			throw new InvalidArgumentException("Invalid property name \"" + propertyName + "\".");
		}
		
		modify();
		
		return localProperties.put(propertyName, value);
!!!326018.java!!!	putProperty(inout property : NameValuePair) : ValueCommonInterface
		
		return putProperty(property.getName(), property.getValue());
!!!326146.java!!!	removeProperty(in propertyName : String) : void
		
		if (hasProperty(propertyName)) {
			localProperties.remove(propertyName);
			modify();
		} else {
			throw new ValueNotFoundException("Property \"" + propertyName + "\" not found.");
		}
!!!326274.java!!!	hasProperty(in propertyName : String) : boolean
		
		if (!isValidTypeName(propertyName)) {
			throw new InvalidArgumentException("Property name \"" + propertyName + "\" is invalid.");
		}
		
		return localProperties.containsKey(propertyName);
!!!326402.java!!!	getObjectNameFromString(in s : String) : String
		
		int dotPos = s.indexOf('.');
		
		if (dotPos < 0) {
			return s;
		} else {
			return s.substring(0, dotPos);
		}
!!!326530.java!!!	getTypeNameFromString(in s : String) : String

		String obj = getObjectNameFromString(s);
		
		int parPos = obj.indexOf('(');
		
		if (parPos < 0) {
			return obj;
		} else {
			return obj.substring(0, parPos);
		}
!!!326658.java!!!	getIndexStringFromString(in s : String) : String
		
		String obj = getObjectNameFromString(s);
		
		int lparPos = obj.indexOf('(');
		
		if (lparPos < 0) {
			return null;
		} else {
			int rparPos = obj.indexOf(')');
			
			String indexString = obj.substring(lparPos + 1, rparPos);
			
			return indexString;
		}
!!!326786.java!!!	getIndexNumberFromString(in s : String) : int
		
		if ((s == null) || (s.length() == 0)) {
			return 0;
		}
		
		try {
			return Integer.valueOf(s).intValue();
		} catch (Exception e) {
			// this should never happen, since we assume correct format
			assert false : "Oh man, you forgot to check syntax of the object path.";
			return 0;
		}
!!!326914.java!!!	getObject(in name : String) : PropertyTreeInterface

		if (!isValidObjectPath(name)) {
			throw new InvalidArgumentException("Invalid object path \"" + name + "\".");
		}
		
		int dotPos = name.indexOf('.');
		
		if (dotPos < 0) {
			String typeName = getTypeNameFromString(name);
			String indexStr = getIndexStringFromString(name);
			
			if ((indexStr != null) && indexStr.equals("?")) {
				throw new InvalidArgumentException("Invalid object path \"" + name + "\". "
						+ "Do not use ? to query for specific object.");
			}
			
			int index = getIndexNumberFromString(indexStr);
			
			ArrayList< PropertyTreeInterface > al = childObjects.get(typeName);
			
			if (al == null) {
				throw new ValueNotFoundException("Unable to find object of type \"" + typeName + "\".");
			}
			
			if (index > al.size() - 1) {
				throw new ValueNotFoundException("Unable to find requested object. Index is too big.");
			}
			
			try {
				return al.get(index);
			} catch (Exception e) {
				assert false : "This should never happen.";
				return null;
			}
		}
		
		// Object is deeper in hierarchy
		PropertyTreeInterface localObject = getObject(getObjectNameFromString(name));
			
		return localObject.getObject(name.substring(dotPos + 1));
!!!327042.java!!!	getObject(in typeName : String, in index : int) : PropertyTreeInterface
		
		if (!isValidTypeName(typeName)) {
			throw new InvalidArgumentException("Invalid object type name \"" + typeName + "\".");
		}
		
		ArrayList< PropertyTreeInterface > al = childObjects.get(typeName);
		
		if (al == null) {
			throw new ValueNotFoundException("No objects of type \"" + typeName + "\" found.");
		}
		
		if ((index > al.size() - 1) || (index < 0)) {
			throw new ValueNotFoundException("Unable to find requested object. Invalid index.");
		}
	
		try {
			return al.get(index);
		} catch (Exception e) {
			assert false : "This should never happen.";
			return null;
		}
!!!327170.java!!!	setIndex(in index : int) : void
		
		modify();
		
		objectIndex = index;
!!!327298.java!!!	addObject(inout object : PropertyTreeInterface) : void

		if (!childObjects.containsKey(object.getTypeName())) {
			ArrayList< PropertyTreeInterface > al = new ArrayList< PropertyTreeInterface >();
			al.add(object);
			childObjects.put(object.getTypeName(), al);
			((PropertyTree) object).setIndex(0);
			((PropertyTree) object).setParent(this);
		} else {
			childObjects.get(object.getTypeName()).add(object);
			((PropertyTree) object).setIndex(childObjects.get(object.getTypeName()).size() - 1);
			((PropertyTree) object).setParent(this);
		}
		
		modify();
!!!327426.java!!!	isLocalName(in s : String) : boolean
		
		return s.indexOf('.') == -1;
!!!327554.java!!!	isWildCardName(in s : String) : boolean
		
		return s.contains("?");
!!!327682.java!!!	removeObject(in name : String) : void
		
		if (!isLocalName(name)) {
			throw new InvalidArgumentException("Unable to delete object which is not direct child of this.");
		}

		String typeName = getTypeNameFromString(name);
		
		if (!childObjects.containsKey(typeName)) {
			throw new ValueNotFoundException("Unable to delete \"" + name + "\". "
					+ "No objects of such type found.");
		}
		
		String indexString = getIndexStringFromString(name);
		
		if (isWildCardName(name)) {
			throw new InvalidArgumentException("Unable to delete object with wildcard in name.");
		}

		int index = getIndexNumberFromString(indexString);
		ArrayList< PropertyTreeInterface > al = childObjects.get(typeName);
		
		if ((index < 0) || (index > al.size() - 1)) {
			throw new ValueNotFoundException("Unable to delete \"" + name + "\". Invalid index.");
		}
		
		al.remove(index);
		
		if (al.size() == 0) {
			childObjects.remove(typeName);
		} else {
			for (int i = index; i < al.size(); ++i) {
				((PropertyTree) al.get(i)).setIndex(i);
			}
		}
		
		modify();
!!!327810.java!!!	removeObject(in typeName : String, in index : int) : void
		
		if (!isValidTypeName(typeName)) {
			throw new InvalidArgumentException("Invalid type name \"" + typeName + "\".");
		}
		
		if (!childObjects.containsKey(typeName)) {
			throw new ValueNotFoundException("No objects of type \"" + typeName + "\" found.");
		}
		
		ArrayList< PropertyTreeInterface > list = childObjects.get(typeName);
		
		if ((index < 0) || (index > list.size() - 1)) {
			throw new ValueNotFoundException("Unable to delete object. Invalid index.");
		}
		
		((PropertyTree) list.get(index)).setParent(null);
		list.remove(index);
		
		if (list.size() == 0) {
			childObjects.remove(typeName);
		} else {
			for (int i = index; i < list.size(); ++i) {
				((PropertyTree) list.get(i)).setIndex(i);
			}
		}
!!!327938.java!!!	removeAllOfType(in type : String) : void
		
		if (!isValidTypeName(type)) {
			throw new InvalidArgumentException("Invalid type name \"" + type + "\".");
		}
		
		if (childObjects.containsKey(type)) {
			ArrayList< PropertyTreeInterface > o = childObjects.get(type);
			
			for (PropertyTreeInterface pt: o) {
				PropertyTree x = (PropertyTree) pt;
				x.setParent(null);
				x.setIndex(-1);
			}
			
			childObjects.remove(type);
			
			modify();
		} else {
			throw new ValueNotFoundException("No object of type \"" + type + "\" found.");
		}
!!!328066.java!!!	getName(inout absolute : boolean) : String
		
		String local = objectName;
		
		if (objectIndex >= 0) {
			boolean single = false;
			if (parent != null) {
				try {
					single = parent.getObjectCount(objectName) == 1;
				} catch (Exception e) {
					// this should never happen, but life's bitch...
					single = false;
				}
			} else {
				single = true;
			}
			local = local + (single ? "" : "(" + String.valueOf(objectIndex) + ")");
		}
		
		if (absolute) {
			if (parent == null) {
				return local;
			}
			return parent.getName(true) + "." + local;
		}
		
		return local;
!!!328194.java!!!	getTypeName() : String
		
		return objectName;
!!!328322.java!!!	getIndex() : int
		
		return objectIndex;
!!!328450.java!!!	getObjectCount() : int
		
		int result = 0;

		for (ArrayList< PropertyTreeInterface > current: childObjects.values()) {
			result += current.size();
		}
		
		return result;
!!!328578.java!!!	getObjectCount(in name : String) : int
		
		if (!isValidTypeName(name)) {
			throw new InvalidArgumentException("Invalid typename \"" + name + "\".");
		}
		
		ArrayList< PropertyTreeInterface > p = childObjects.get(name);
		
		if (p == null) {
			return 0;
		} else {
			return p.size();
		}
!!!328706.java!!!	getPropertyCount() : int
		
		return localProperties.size();
!!!328834.java!!!	findAllOfType(in objTypeName : String, inout fixed : List< NameValuePair >) : PropertyTreeInterface
		
		if (!isValidTypeName(objTypeName)) {
			throw new InvalidArgumentException("Invalid type name \"" + objTypeName + "\".");
		}
		
		ArrayList< PropertyTreeInterface > result = new ArrayList< PropertyTreeInterface >();
		
		if (objTypeName.equals(objectName)) {
			
			boolean addThis = true;
			
			if (fixed != null) {
				for (NameValuePair current: fixed) {
					try {
						if (!criteriaTest(getPropertyValue(current.getName()), current.getValue())) {
							addThis = false;
							break;
						}
					} catch (Exception e) {
						addThis = false;
						break;
					}
				}
			}
			
			if (addThis) {
				result.add(this);
			}
		} else {
			for (Iterator< PropertyTreeReadInterface > it = this.getObjectIterator(); it.hasNext(); ) {
				PropertyTree current = (PropertyTree) it.next();
				
				result.addAll(current.findAllOfType(objTypeName, fixed));
			}
		}
		
		return result;
!!!328962.java!!!	test(inout restriction : RestrictionInterface, inout ignoreMissing : boolean) : boolean

		boolean result = false;

		if (restriction instanceof ObjectRestriction) {
			try {
				result = testSingle((ObjectRestriction) restriction, ignoreMissing);
			} catch (ValueNotFoundException e) {
				if (!ignoreMissing) {
					throw e;
				}
			}
		} else if (restriction instanceof AlternativeRestriction) {
			try {
				result = testSingle((AlternativeRestriction) restriction, ignoreMissing);
			} catch (ValueNotFoundException e) {
				if (!ignoreMissing) {
					throw e;
				}
			}
		} else if (restriction instanceof RSLRestriction) {
			result = ((RSLRestriction) restriction).test(this, ignoreMissing);
		} else {
			throw new HostManagerException("Unknown restriction type \""
					+ restriction.getClass().getCanonicalName() + "\".");
		}
	
		return result;
!!!329090.java!!!	test(inout restrictions : RestrictionInterface, inout ignoreMissing : boolean) : boolean
		
		for (RestrictionInterface r: restrictions) {
			
			if (!test(r, ignoreMissing)) {
				return false;
			}
		}
		
		return true;
!!!329218.java!!!	testSingle(inout restriction : ObjectRestriction, inout ignoreMissing : boolean) : boolean

		if (restriction.getObjectPath().length() == 0) {
			// Object path is empty, test properties of this object
			
			for (NameValuePair current: restriction.getProperties()) {
				try {
					if (!criteriaTest(getPropertyValue(current.getName()), current.getValue())) {
						return false;
					}
				} catch (ValueNotFoundException e) {
					if (ignoreMissing) {
						return false;
					} else {
						throw e;
					}
				} catch (Exception e) {
					return false;
				}
			}
			
			return true;
		} else {
			
			String objName = getObjectNameFromString(restriction.getObjectPath());
			String pathPostfix = "";
			
			if (restriction.getObjectPath().indexOf('.') != -1) {
				restriction.getObjectPath().substring(objName.length());
			}

			// build restriction used for all child objects
			ObjectRestriction childRestriction = 
				new ObjectRestriction(pathPostfix, restriction.getProperties());

			if (objName.indexOf('?') != -1) {
				// search for object in the list of all objects of given type.
				
				String objTypeName = getTypeNameFromString(restriction.getObjectPath());
				
				if (!childObjects.containsKey(objTypeName)) {
					if (ignoreMissing) {
						return false;
					} else {
						throw new ValueNotFoundException("Unable to find object of type \""
								+ objTypeName + "\".");
					}
				}

				for (PropertyTreeInterface current: childObjects.get(objTypeName)) {
					PropertyTree c = (PropertyTree) current;
					
					try {
						if (c.testSingle(childRestriction, ignoreMissing)) {
							// we have found matching child object, no need to test further objects
							return true;
						}
					} catch (ValueNotFoundException e) {
						// this is not necessary, but resulting exception is nicer :)
						throw new ValueNotFoundException("Unable to find child object of \""
								+ objTypeName + "\".", e);
					}
				}
				
				// we didn't find any matching object, what a shame
				return false;
			} else {
				// exact path, test one object only

				try {
					return ((PropertyTree) getObject(objName)).testSingle(childRestriction, ignoreMissing);
				} catch (ValueNotFoundException e) {
					// again, make exception more informative (hopefuly)
					throw new ValueNotFoundException("Unable to find child object of \""
							+ objName + "\".", e);
				}
			}
		}
!!!329346.java!!!	testSingle(inout alt : AlternativeRestriction, inout ignoreMissing : boolean) : boolean
		
		ObjectRestriction []restrictions = alt.getRestrictions();
		boolean result = false;
		
		// test all restrictions in list
		for (int i = 0; i < restrictions.length; ++i) {
			
			result = result | testSingle(restrictions[i], ignoreMissing);
		}
		
		return result;
!!!329474.java!!!	criteriaTest(inout value : ValueCommonInterface, inout criteria : ValueCommonInterface) : boolean
		
		if (criteria instanceof ValueList) {
			if (value instanceof ValueList) {
				return ((ValueList) criteria).equals((ValueList) value);
			} else if (value instanceof ValueBasicInterface) {
				return ((ValueList) criteria).contains((ValueBasicInterface) value);
			} else {
				throw new ValueTypeIncorrectException("Unable to compare \""
						+ criteria.getClass().getCanonicalName() + "\" with \""
						+ value.getClass().getCanonicalName() + "\".");
			}
		} else if (criteria instanceof ValueRange) {
			if (value instanceof ValueRange) {
				return ((ValueRange) criteria).equals((ValueRange) value);
			} else if (value instanceof ValueBasicInterface) {
				return ((ValueRange) criteria).contains((ValueBasicInterface) value);
			} else {
				throw new ValueTypeIncorrectException("Unable to compare \""
						+ criteria.getClass().getCanonicalName() + "\" with \""
						+ value.getClass().getCanonicalName() + "\".");
			}
		} else if (criteria instanceof ValueRegexp) {
			if (value instanceof ValueRegexp) {
				return ((ValueRegexp) criteria).equals((ValueRegexp) value);
			} else if (value instanceof ValueBasicInterface) {
				return ((ValueRegexp) criteria).match(value.toString());
			} else {
				throw new ValueTypeIncorrectException("Unable to compare \""
						+ criteria.getClass().getCanonicalName() + "\" with \""
						+ value.getClass().getCanonicalName() + "\".");
			}
		} else if (criteria instanceof ValueBasicInterface) {
			return criteria.equals(value);
		} else {
			throw new HostManagerException("Unknown criteria type \""
					+ criteria.getClass().getCanonicalName() + "\".");
		}
!!!329602.java!!!	setParent(inout newParent : PropertyTreeInterface) : void
		
		parent = newParent;
		
		modify();
!!!329730.java!!!	getParent() : PropertyTreeInterface
		
		return parent;
!!!329858.java!!!	getRoot() : PropertyTreeInterface
		
		if (parent == null) {
			return this;
		} else {
			return ((PropertyTree) parent).getRoot();
		}
!!!329986.java!!!	toString() : String
		
		return getName(false);
!!!330114.java!!!	isValidObjectPath(in path : String) : boolean

		return PropertyTreeFactory.isValidObjectPath(path);
!!!330242.java!!!	isValidPropertyPath(in path : String) : boolean
		
		return PropertyTreeFactory.isValidPropertyPath(path);
		
!!!330370.java!!!	isValidTypeName(in tname : String) : boolean
		
		return PropertyTreeFactory.isValidTypeName(tname);
!!!330498.java!!!	hashCode() : int

		return rehash();
!!!330626.java!!!	equals(inout o : Object) : boolean
		
		if (o instanceof PropertyTree) {
			PropertyTree p = (PropertyTree) o;
			
			if (!this.objectName.equals(p.objectName)
				|| this.getObjectCount() != p.getObjectCount()
				|| this.getPropertyCount() != p.getPropertyCount()) {
				
				return false;
			}
			
			// well, we have to dig deeper to find differences
			
			// test properties
			for (Iterator< NameValuePair > it = this.getPropertyIterator(); it.hasNext(); ) {
				NameValuePair left = it.next();
				ValueCommonInterface right = null;
				
				try {
					right = p.getPropertyValue(left.getName());
				} catch (Exception e) {
					return false;
				}
				
				if (!left.getValue().equals(right)) {
					return false;
				}
			}
			
			// test objects
			for (Iterator< String > it = childObjects.keySet().iterator(); it.hasNext(); ) {
				String currentTypeName = it.next();
				
				ArrayList< PropertyTreeInterface > left = childObjects.get(currentTypeName);
				ArrayList< PropertyTreeInterface > right = p.childObjects.get(currentTypeName);
				
				if (!left.equals(right)) {
					return false;
				}
			}
			
			return true;
		} else {
			return false;
		}
!!!330754.java!!!	getObjectIterator() : PropertyTreeReadInterface
		return new ObjectIterator();
!!!330882.java!!!	getPropertyIterator() : NameValuePair
		return new PropertyIterator();
!!!331010.java!!!	modify() : void
		
		modificationCount += 1;
!!!331138.java!!!	reset() : void
		
		resetModCount = modificationCount;
!!!331266.java!!!	rehash() : int
		
		// do we need to update hash code cache?
		if (hashCacheModCount != modificationCount) {
			hashCache = 19840627; // <- yes, I'm that mean...
			
			hashCache += getName(false).hashCode() * 31;
			
			// just simple addition, since order of the elements is not important in the comparison
			for (Iterator< PropertyTreeReadInterface > it = this.getObjectIterator(); it.hasNext(); ) {
				hashCache += it.next().hashCode();
			}
			
			for (Iterator< NameValuePair > it = this.getPropertyIterator(); it.hasNext(); ) {
				hashCache += it.next().hashCode();
			}
			
			hashCacheModCount = modificationCount;
		}
		
		return hashCache;
