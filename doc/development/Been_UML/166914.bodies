class HostIndexEntry
!!!351746.java!!!	HostIndexEntry(in newHostName : String, in newDataFile : String, in newLoadFile : String, in newLoadMapFile : String, inout newDate : Date)
		
		hostName = newHostName;
		dataFile = newDataFile;
		loadFile = newLoadFile;
		loadMapFile = newLoadMapFile;
		date = newDate;
		historyEntries = new HashMap< Date, String >();
		newestEntry = null;
		modified = true;
!!!351874.java!!!	HostIndexEntry(inout node : Node)

		historyEntries = new HashMap< Date, String >();
		
		parseXMLNode(node);
		
		newestEntry = null;
		modified = false;
!!!352002.java!!!	parseXMLNode(inout node : Node) : void
		
		/* One node looks like this:
		   
		   <host name="minimal.kolej.mff.cuni.cz" file="minimal.kolej.mff.cuni.cz.host" 
		         load="minimal.kolej.mff.cuni.cz.load" date="2006/03/15 18:25.15"
		         loadmap="minimal.kolej.mff.cuni.cz.loadmap">
			   <history date="2006/03/15 18:25.15" file="minimal.kolej.mff.cuni.cz.2006-03-15-18-25-15.history"/>
		   </host>
		   
		   There can be any number of history sub-nodes. All attributes are mandatory.
		 */
		
		SimpleDateFormat format = new SimpleDateFormat(HostManagerInterface.DEFAULT_DATE_TIME_FORMAT);
		
		hostName = XMLHelper.getAttributeValueByName("name", node);
		dataFile = XMLHelper.getAttributeValueByName("file", node);
		loadFile = XMLHelper.getAttributeValueByName("load", node);
		loadMapFile = XMLHelper.getAttributeValueByName("loadmap", node);
		
		try {
			date = format.parse(XMLHelper.getAttributeValueByName("date", node));
		} catch (ParseException e) {
			throw new InputParseException("Error parsing entry date.", e);
		}
		
		ArrayList< Node > hist = XMLHelper.getChildNodesByName("history", node);
		
		for (Iterator< Node > it = hist.iterator(); it.hasNext(); ) {
			
			Node current = it.next(); 
			Date histDate = null;
			
			try {
				histDate = format.parse(XMLHelper.getAttributeValueByName("date", current));
			} catch (ParseException e) {
				throw new InputParseException(e);
			}
		
			String file = XMLHelper.getAttributeValueByName("file", current);
			
			historyEntries.put(histDate, file);
		}
!!!352130.java!!!	getHistoryLength() : int
		
		return historyEntries.size();
!!!352514.java!!!	getHistoryEntryDates() : List< Date >
		
		ArrayList< Date > result = new ArrayList< Date >();
		
		result.addAll(historyEntries.keySet());
		result.add(date);
		
		Collections.sort(result, new ReverseComparator());
		
		return result;
!!!352642.java!!!	getHistoryEntry(inout entryDate : Date) : String
		
		if (entryDate.equals(date)) {
			return dataFile;
		} else {
			String result = historyEntries.get(entryDate);
			
			if (result == null) {
				throw new ValueNotFoundException("Unable to find history entry for date \""
						+ MiscUtils.formatDate(entryDate, HostManagerInterface.DEFAULT_DATE_TIME_FORMAT)
						+ "\".");
			} else {
				return result;
			}
		}
!!!352770.java!!!	getHistoryEntryList() : Pair
		
		ArrayList< Pair< Date, String > > list = new ArrayList< Pair< Date, String > >();
		
		for (Map.Entry< Date, String > entry: historyEntries.entrySet()) {
			list.add(new Pair< Date, String >(entry.getKey(), entry.getValue()));
		}
		
		list.add(new Pair< Date, String >(date, dataFile));
		
		Collections.sort(list, new ReversePairComparator());
		
		return list;
!!!352898.java!!!	addNewEntry(inout entryDate : Date, in entryFile : String) : void
		
		if (getNewestEntry() != null) {
			try {
				if (!entryDate.after(getNewestEntry().getFirst())) {
					// new date is not after the latest date from the history
					throw new InvalidArgumentException("New date is before the latest "
							+ "date from the history.");
				}
				
				if (hasHistoryEntryForDate(entryDate)) {
					// entry with specified date already exists
					throw new InvalidArgumentException("Entry with specified date is already "
							+ "in the index entry.");
				}
			} catch (Exception e) {
				e.printStackTrace();
				throw new InvalidArgumentException(e);
			}
		}
		
		try {
			historyEntries.put(date, dataFile);
			date = entryDate;
			dataFile = entryFile;
			newestEntry = getNewestHistoryEntry();
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		modified = true;
!!!353026.java!!!	addHistoryEntry(inout entryDate : Date, in entryFile : String) : void
		
		if (historyEntries.containsKey(entryDate)) {
			// History entry with given date is already in the history
			throw new InvalidArgumentException("Entry with specified date is already in the history.");
		} else {
			historyEntries.put(entryDate, entryFile);
			modified = true;
			if ((newestEntry == null) || (entryDate.after(newestEntry.getFirst()))) {
				newestEntry = new Pair< Date, String >(entryDate, entryFile);
			}
		}
!!!353154.java!!!	removeHistoryEntry(inout entryDate : Date) : void

		if (entryDate.equals(date)) {
			Pair< Date, String > newTop = getNewestHistoryEntry();
			
			if (newTop != null) {
				date = newTop.getFirst();
				dataFile = newTop.getSecond();
			
				historyEntries.remove(newTop.getFirst());
			} else {
				date = null;
				dataFile = null;
			}
		} else {
			if (historyEntries.containsKey(entryDate)) {
				historyEntries.remove(entryDate);
				newestEntry = null;
			} else {
				throw new ValueNotFoundException("Unable to remove entry for date \""
						+ MiscUtils.formatDate(entryDate, HostManagerInterface.DEFAULT_DATE_TIME_FORMAT)
						+ "\", entry does not exist.");
			}
		}
		
		modified = true;
!!!353282.java!!!	hasHistoryEntryForDate(inout testDate : Date) : boolean
		
		return (historyEntries.containsKey(testDate)) || (date.equals(testDate));
!!!353410.java!!!	clearHistory() : String
		
		String []res = new String[historyEntries.size()];

		historyEntries.values().toArray(res);
		historyEntries.clear();
		
		newestEntry = null;
		modified = true;
		
		return res;
!!!353538.java!!!	getLoadFileName() : String
		
		return loadFile;
!!!353666.java!!!	getLoadMapFileName() : String
		
		return loadMapFile;
!!!353794.java!!!	getDataFileName() : String
		
		return dataFile;
!!!353922.java!!!	getHostName() : String
		
		return hostName;
!!!354050.java!!!	getCurrentEntryDate() : Date
		
		return date;
!!!354178.java!!!	exportAsElement(inout document : Document) : Element
		
		Element entry = document.createElement("host");
		
		entry.setAttribute("name", hostName);
		entry.setAttribute("file", dataFile);
		entry.setAttribute("load", loadFile);
		entry.setAttribute("loadmap", loadMapFile);
		entry.setAttribute("date", MiscUtils.formatDate(date, HostManagerInterface.DEFAULT_DATE_TIME_FORMAT));
		
		Set< Date > dates = historyEntries.keySet();
		SimpleDateFormat formater = new SimpleDateFormat(HostManagerInterface.DEFAULT_DATE_TIME_FORMAT);
		
		for (Date current: dates) {
			Element historyElement = document.createElement("history");
			
			historyElement.setAttribute("date", formater.format(current));
			historyElement.setAttribute("file", historyEntries.get(current));
			
			entry.appendChild(historyElement);
		}
		
		return entry;
!!!354306.java!!!	getNewestHistoryEntry() : Pair
		
		if (newestEntry == null) {
			// we have to recalculate "cache"
			Pair< Date, String > current = null;
		
			for (Map.Entry< Date, String > tested: historyEntries.entrySet()) {
				if (current == null) {
					current = new Pair< Date, String >(tested.getKey(), tested.getValue());
				} else if (tested.getKey().after(current.getFirst())) {
					current = new Pair< Date, String >(tested.getKey(), tested.getValue());
				}
			}
			
			newestEntry = current;
		}
		
		return newestEntry;
!!!354434.java!!!	getNewestEntry() : Pair
		
		Pair< Date, String > ne = getNewestHistoryEntry();
		
		if (ne != null) {
			if (ne.getFirst().after(date)) {
				return newestEntry;
			} else {
				return new Pair< Date, String >(date, dataFile);
			}
		} else {
			return null;
		}
!!!354562.java!!!	isModified() : boolean
		
		return modified;
!!!354690.java!!!	isModified(inout reset : boolean) : boolean
		
		boolean result = modified;
		
		if (reset) {
			modified = false;
		}
		
		return result;
!!!354818.java!!!	saved() : void
		
		modified = false;
!!!354946.java!!!	toString() : String
		String result = hostName + "={";
		
		List< Pair< Date, String > > list = getHistoryEntryList();
		
		for (Iterator< Pair< Date, String > > it = list.iterator(); it.hasNext(); ) {
			result += it.next().getSecond() + (it.hasNext() ? ", " : "");
		}
		
		return result + "}";
!!!355074.java!!!	getXMLNodeName() : String
		
		return "host";
