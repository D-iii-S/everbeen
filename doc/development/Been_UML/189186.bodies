class RunValidityMapsManager
!!!592386.java!!!	getInstance() : RunValidityMapsManager
		if (rvmInstance == null) {
			rvmInstance = new RunValidityMapsManager();
		}
		return rvmInstance;
!!!592514.java!!!	initialize(inout database : Database, inout rolesManager : RolesManager) : void
		RunValidityMapsManager.database = database;
		RunValidityMapsManager.rolesManager = rolesManager;
!!!592642.java!!!	openRRIDTable(inout aid : AID, inout eid : EID, inout bid : BID) : void
		
		/* Test, if we haven't validity map in the memory */
		// note: comment this if out, if you want to disable caching of validity
		// maps
		
		// NOTE: synchronization for reading
		
		/*if (tableAID != null && tableEID != null && tableBID != null 
				&& aid.equals(tableAID) && (eid.equals(tableEID)) && (bid.equals(tableBID))) {
			return;
		}*/
		
		/* Load it */
		try {
			table = new RRIDTable(database.getFileInDatabase(aid, eid, bid, 
					BINARY_VALIDITYMAP_FILENAME));
		} catch (IOException e) {
			e.printStackTrace();
			Logger.logError(RRIDTable.IO_ERROR_VALIDITY_READING_MESSAGE 
					+ Database.getBinaryReferenceString(aid, eid, bid));
			
			table = new RRIDTable();
			tableAID = new AID(-1);
			tableEID = new EID(-1);
			tableBID = new BID(-1);
			
			return;
		}
		
		/* Remember actual validity map position, we are working with */
		tableAID = aid;
		tableEID = eid;
		tableBID = bid;		
	
!!!592770.java!!!	storeRRIDTable() : void
			table.store(database.getFileInDatabase(tableAID, tableEID, tableBID, 
					BINARY_VALIDITYMAP_FILENAME));
!!!592898.java!!!	generateNewFilename(inout aid : AID, inout eid : EID, inout bid : BID, inout rid : RID, in tableIndex : int, in totalTables : int, in hostName : String, in roleName : String, inout runValid : boolean) : String

		MetadataRef binaryMetadata = new MetadataRef(new Metadata());
		Integer lastValidRunIndex;
		Integer lastCrashedRunIndex;
		String returnValue;
		
		rolesManager.loadRoleList(aid, eid);
		long roleHostKey = rolesManager.getKeyOfHostname(hostName);
		
		if (roleHostKey == -1) {
			Logger.logError("Host " + hostName + " not registered for results upload for a given experiment!");
			
			return null;
		}
		
		Logger.logTrace("The key of item read is : " + roleHostKey);
		
		int itemIndex = rolesManager.getItemIndex(roleHostKey);
		
		Logger.logTrace("The index of item read is : " + roleHostKey);
		RoleItem roleItem = rolesManager.getRoleItem(itemIndex);
		
		Logger.logTrace("The role name to be checked is " + roleItem.getRoleName());
		Logger.logTrace("The host name to be checked is " + roleItem.getHostName());
		
		if (!roleItem.getRoleName().equals(roleName) ||
				!roleItem.getHostName().equals(hostName)) {
			Logger.logError("Role for " + hostName + " should be \"" + roleItem.getRoleName() +
					"\", but is \"" + roleName + "\".");
			return null;
		}

		/* Read metadata from binary */
		if (!BinaryEntityManager.ensureSuccessLoadBinaryMetadata(binaryMetadata, 
				aid, eid, bid)) {
			throw new IOException("Metadata reading error - see logs for details.");
		}		

		/* Now read info about indexes */
		String metaItem = binaryMetadata.metadata.getItemByKey("last valid run idx");
		if (metaItem == null) {
			Logger.logError(
					"Error reading binary metadata item"
							+ "'last valid run idx' - null ("
							+ Database.getBinaryReferenceString(aid, eid, bid) + ").");
			lastValidRunIndex = new Integer(0);
		} else {
			lastValidRunIndex = new Integer(metaItem);
		}

		metaItem = binaryMetadata.metadata.getItemByKey("last crashed run idx");
		if (metaItem == null) {
			Logger.logError(
					"Error reading binary metadata item"
							+ "'last crashed run idx' - null ("
							+ Database.getBinaryReferenceString(aid, eid, bid) + ").");
			lastCrashedRunIndex = new Integer(0);
		} else {
			lastCrashedRunIndex = new Integer(metaItem);
		}

		if (runValid) {
			
			openRRIDTable(aid, eid, bid);
			
			RRIDItem item;
			
			item = table.getItemByKey(rid);
						
			if (item != null) {
				
				returnValue = item.getIndexOfTable() + "-" + tableIndex + "-" + roleHostKey;
				Logger.logDebug("Adding new file to already existing run: " + returnValue);
				
			} else {
				
				returnValue = lastValidRunIndex.toString() + "-" + tableIndex + "-" + roleHostKey;
				
				Logger.logDebug("VALIDITY MAP UPDATE - Increasing index of valid runs");
				
				lastValidRunIndex++;
				lastCrashedRunIndex = 0;
				
			}
			
			if (table.isValueInTable(returnValue)) {
				throw new IOException("Item already added into validity map, RID(" + rid 
						+ "), table(" + tableIndex + "), role(" + roleHostKey + ", value " 
						+ returnValue + " for " + Database.getBinaryReferenceString(aid, eid, bid) 
						+ ".");
			}

			table.addItem(new RRIDItem(rid, runValid, returnValue, 
					Long.valueOf(roleHostKey)));
			try {
				storeRRIDTable();
			} catch (IOException e) {
				e.printStackTrace();
				Logger.logError(
						RRIDTable.IO_ERROR_VALIDITY_STORING_MESSAGE
								+ "of " + Database.getBinaryReferenceString(aid, eid, bid) + ".");
				throw e;
			}

			binaryMetadata.metadata.setItemByKey("last valid run idx", lastValidRunIndex
					.toString());
			binaryMetadata.metadata.setItemByKey("last crashed run idx",
					lastCrashedRunIndex.toString());
			
			if (!BinaryEntityManager.ensureSuccessStoreBinaryMetadata(binaryMetadata.metadata, 
					aid, eid, bid)) {
				throw new IOException("Metadata storing error - see logs for details.");
			}

			return returnValue; 

		} else {

			openRRIDTable(aid, eid, bid);
			
			RRIDItem item;
			
			item = table.getItemByKey(rid);
			
			if (item != null) {
				
				returnValue = item.getIndexOfTable() + "-" + tableIndex + "-" + roleHostKey;
				Logger.logDebug("Adding new file to already existing invalid run: " + returnValue);
				
			} else {
						
				returnValue = lastValidRunIndex.toString() + "."
				+ lastCrashedRunIndex.toString() + "-" + tableIndex + "-" + roleHostKey;
				
				Logger.logDebug("VALIDITY MAP UPDATE - Increasing index of crashed runs");
				
				lastValidRunIndex++;
				lastCrashedRunIndex = 0;
				
			}
			
			if (table.getItemByKey(rid) != null || table.isValueInTable(returnValue)) {
				throw new IOException("Item already added into validity map, RID " + rid 
						+ ", value " + returnValue + " for " 
						+ Database.getBinaryReferenceString(aid, eid, bid) + "."); 
			}
			table.addItem(new RRIDItem(rid, runValid, returnValue,
					Long.valueOf(roleHostKey)));
			try {
				storeRRIDTable();
			} catch (IOException e) {
				e.printStackTrace();
				Logger.logError(
						RRIDTable.IO_ERROR_VALIDITY_STORING_MESSAGE
								+ "of " + Database.getBinaryReferenceString(aid, eid, bid) + ".");
				throw e;
			}

			binaryMetadata.metadata.setItemByKey("last valid run idx", lastValidRunIndex
					.toString());
			binaryMetadata.metadata.setItemByKey("last crashed run idx",
					lastCrashedRunIndex.toString());
			
			if (!BinaryEntityManager.ensureSuccessStoreBinaryMetadata(binaryMetadata.metadata, 
					aid, eid, bid)) {
				throw new IOException("Metadata storing error - see logs for details.");
			}			

			return returnValue; 

		}
!!!593026.java!!!	getRunCount(inout aid : AID, inout eid : EID, inout bid : BID) : int
		openRRIDTable(aid, eid, bid);
		return table.getItemCount();
!!!593154.java!!!	isValidRun(inout aid : AID, inout eid : EID, inout bid : BID, inout rid : RID) : boolean
		openRRIDTable(aid, eid, bid);
		return table.getValidityByKey(rid);
!!!593282.java!!!	getRunPaths(inout aid : AID, inout eid : EID, inout bid : BID, inout rid : RID) : String

		File runDir = new File(database.getDirectoryInDatabase(aid, eid, bid));
		if (!runDir.exists() || !runDir.isDirectory()) {
			return null;
		}

		openRRIDTable(aid, eid, bid);		

		if ((table == null) || (table.getItemByKey(rid) == null)) {
		    return null;		    
		}
				
		return new String[] { table.getItemByKey(rid).getTableName() };

!!!593410.java!!!	getRunMetadataPath(inout aid : AID, inout eid : EID, inout bid : BID, inout rid : RID) : String

		String name;

		File runDir = new File(database.getDirectoryInDatabase(aid, eid, bid));
		if (!runDir.exists() || !runDir.isDirectory()) {
			return null;
		}

		openRRIDTable(aid, eid, bid);
		name = rid.toString();

		return name + META_TYPE;
!!!593538.java!!!	getRunLoadGraphsPath(inout aid : AID, inout eid : EID, inout bid : BID, inout rid : RID) : String

		String loadDir = database.getLoadDirectory(aid, eid, bid) + File.separator + rid;

		File loadDirFile = new File(loadDir);

		if (!loadDirFile.exists() || !loadDirFile.isDirectory()) {
			return null;
		}

		String loadGraphTable = loadDir + File.separator + "load.graphs";
		File loadGraphFile = new File(loadGraphTable);

		if (loadGraphFile.exists()) {
			Logger.logDebug("Graph loads already generated...");
			return loadDir;			
		} else {
			Logger.logDebug("Generating graphs for load...");
			if (RManager.getInstance().rScriptingEnabled()) {
				RManager.executeRCommand("load.generateGraphs("
					+ aid + "," + eid + "," + bid + "," + rid + ");");
			}
			return loadDir;
		}

!!!593666.java!!!	getRunStatisticsPath(inout aid : AID, inout eid : EID, inout bid : BID, inout rid : RID) : String

		String name;

		File runDir = new File(database.getDirectoryInDatabase(aid, eid, bid));
		if (!runDir.exists() || !runDir.isDirectory()) {
			return null;
		}

		openRRIDTable(aid, eid, bid);
		name = rid.toString();

		return name + STATISTIC_TYPE;
!!!593794.java!!!	getRunTable(inout aid : AID, inout eid : EID, inout bid : BID) : RRIDTable
		openRRIDTable(aid, eid, bid);
		return table;
!!!593922.java!!!	readFileList(inout aid : AID, inout eid : EID, inout bid : BID) : ArrayList<File>

		ArrayList<File> returnValue;
		returnValue = new ArrayList<File>();

		openRRIDTable(aid, eid, bid);
		String pathToBin = database.getDirectoryInDatabase(aid, eid, bid);

		
		for (RRIDItem rridItem : table.getRridTable()) {
			returnValue.add(new File(pathToBin + File.separator + rridItem.getTableName()));
		}


		return returnValue;
!!!594050.java!!!	deleteItem(inout aid : AID, inout eid : EID, inout bid : BID, inout rid : RID) : void
		
		openRRIDTable(aid, eid, bid);
		table.deleteItemByKey(rid);
		try {
			storeRRIDTable();
		} catch (IOException e) {
			e.printStackTrace();
			Logger.logError(
					RRIDTable.IO_ERROR_VALIDITY_STORING_MESSAGE
							+ "runs of " + Database.getBinaryReferenceString(aid, eid, bid) 
							+ "when deleting run " + rid + ".");			
		}
!!!594178.java!!!	allHostsUploaded(inout aid : AID, inout eid : EID, inout bid : BID, inout rid : RID, in totalTables : int) : boolean
		
		int tableCount, expectedHostCount;
		
		rolesManager.loadRoleList(aid, eid);
		expectedHostCount = rolesManager.getRoleCount();
		Logger.logTrace("Validity Maps: Expected hosts count is : " + rolesManager.getRoleCount());
		Logger.logTrace("Validity Maps: Reported total table count for this run is : " + totalTables);
		tableCount = 0;
		
		openRRIDTable(aid, eid, bid);
		for (RRIDItem rridItem : table.getRridTable()) {
			if (rridItem.getKey().equals(rid)) {
				tableCount++;
			}
		}
		
		Logger.logTrace("Validity Maps: Table count is now " + tableCount);

		if (tableCount > expectedHostCount * totalTables)
			Logger.logWarning("Inconsistent Results Repository: real tables count (" + tableCount 
					+") is greater than maximal expected host count (" + expectedHostCount + ")");
		
		return (tableCount == expectedHostCount * totalTables);
!!!594306.java!!!	getRealRunIndex(inout aid : AID, inout eid : EID, inout bid : BID, inout rid : RID) : long
		
		openRRIDTable(aid, eid, bid);
		
		return table.getRealRunIndex(table.getItemIndexByKey(rid));		
!!!594434.java!!!	decreaseIndexByOne(in index : int) : void
		
		table.decreaseIndexByOne(index);
		
		try {
			storeRRIDTable();
		} catch (IOException e) {
			e.printStackTrace();
			Logger.logError(
					RRIDTable.IO_ERROR_VALIDITY_STORING_MESSAGE
							+ "run when reindexing after delete.");			
		}		
