class HostRuntimeImplementation
!!!475394.java!!!	getRootDirectory() : String
		return rootDirectory;
!!!475522.java!!!	getTaskManager() : TaskManagerInterface
		return taskManager;
!!!475650.java!!!	getHostRuntimesPort() : HostRuntimesPortInterface
		return hostRuntimesPort;
!!!475778.java!!!	getPackageCacheManager() : PackageCacheManager
		return packageCacheManager;
!!!475906.java!!!	getLoadMonitor() : LoadMonitorInterface
		return loadMonitor;
!!!476034.java!!!	checkDirectory(in directoryName : String) : void
		File directory = new File(directoryName);
		if (!directory.exists()) {
			throw new FileNotFoundException("Error: \"" + directory + "\" does not exist.");
		}
		if (!directory.isDirectory()) {
			throw new FileNotFoundException("Error: \"" + directory + "\" is not directory.");
		}
		if (!directory.canWrite()) {
			throw new IOException("Error: \"" + directory + "\" is not writable.");
		}
!!!476162.java!!!	deleteContext(in contextID : String) : void
		try {
			Delete.deleteDirectory(rootDirectory
				+ File.separator + TASKS_BASE_DIR
				+ File.separator + contextID);
		} catch (AntTaskException e) {
			throw new HostRuntimeException(e);
		}

		try {
			loadMonitor.clearDetailedModeData(contextID);
		} catch (IllegalOperationException e) {
			throw new HostRuntimeException(e);
		} catch (RemoteException e) {
			throw new AssertionError("RemoteException should not happen in local call.");
		} catch (ValueNotFoundException e) {
			throw new HostRuntimeException(e);
		}
!!!476290.java!!!	deleteOldClosedContexts() : void
		synchronized (closedContexts) {
			while (closedContexts.size() > keptClosedContextCount) {
				deleteContext(closedContexts.get(0));
				closedContexts.remove(0);
			}
		}
!!!476418.java!!!	HostRuntimeImplementation(in taskManagerHostname : String, in rootDirectory : String)
		String cacheDir = rootDirectory + File.separator + CACHE_DIR;
		String bootPackagesDir = rootDirectory + File.separator + BOOT_PACKAGES_DIR;
		String nativeLibDir = rootDirectory + File.separator + NATIVE_LIB_DIR;
		String loadDir = rootDirectory + File.separator + LOAD_DIR;
		String tasksBaseDir = rootDirectory + File.separator + TASKS_BASE_DIR;
		
		checkDirectory(rootDirectory);
		checkDirectory(cacheDir);
		checkDirectory(bootPackagesDir);
		checkDirectory(nativeLibDir);
		checkDirectory(loadDir);
		checkDirectory(tasksBaseDir);
		
		this.rootDirectory = rootDirectory;
		
		packageCacheManager = new PackageCacheManager(cacheDir, bootPackagesDir);
		loadMonitor = new LoadMonitorImplementation(nativeLibDir, loadDir);
		
		Naming.rebind("rmi://localhost:1099" + HostRuntimeInterface.URL, this);

		/* Initialize the Task Manager reference and register the Host Runtime. */
		try {
			hostRuntimesPort = (HostRuntimesPortInterface) Naming.lookup(
				"//" + taskManagerHostname + TaskManagerInterface.URL
			);
		} catch (MalformedURLException e) {
			throw new AssertionError("MalformedURLException could not be thrown.");
		}
		taskManager = hostRuntimesPort.getTaskManager();
		taskManager.registerHostRuntime(InetAddress.getLocalHost().getCanonicalHostName());

		/* If the Host Runtime shuts down, kill all running tasks. */ 
		Runtime.getRuntime().addShutdownHook(new Thread() {
			public void run() {
				synchronized (runningTasks) {
					for (TaskInterface task : runningTasks) {
						try {
							task.kill();
						} catch (RemoteException e) {
							System.err.println("Error executing remote call from the Host Runtime to the task.");
						}
					}
				}
				
				try {
					loadMonitor.terminate();
				} catch (RemoteException e) {
					throw new AssertionError("Local call should not fail.");
				}

				try {
					taskManager.unregisterHostRuntime(InetAddress.getLocalHost().getCanonicalHostName());
				} catch (RemoteException e) {
					System.err.println("Error executing remote call from the Host Runtime to the Task Manager.");
				} catch (UnknownHostException e) {
					System.err.println(e.getMessage());
				}
			}
		});
!!!476546.java!!!	getBaseDirectoryForTask(in contextID : String, in taskID : String) : String
		return rootDirectory
			+ File.separator + TASKS_BASE_DIR
			+ File.separator + contextID 
			+ File.separator + taskID; 
!!!476674.java!!!	getTaskDirectoryForTask(in contextID : String, in taskID : String) : String
		return getBaseDirectoryForTask(contextID, taskID)
			+ File.separator + TASK_DIR; 
!!!476802.java!!!	getWorkingDirectoryForTask(in contextID : String, in taskID : String) : String
		return getBaseDirectoryForTask(contextID, taskID)
			+ File.separator + WORKING_DIR; 
!!!476930.java!!!	getTemporaryDirectoryForTask(in contextID : String, in taskID : String) : String
		return getBaseDirectoryForTask(contextID, taskID)
			+ File.separator + TEMPORARY_DIR; 
!!!477058.java!!!	getServiceDirectoryForTask(in contextID : String, in taskID : String) : String
		return getBaseDirectoryForTask(contextID, taskID)
			+ File.separator + SERVICE_DIR; 
!!!477186.java!!!	notifyTaskFinished(inout task : TaskInterface) : void
		runningTasks.remove(task);
!!!477314.java!!!	initialize(inout hostRuntimesPort : HostRuntimesPortInterface, in maxPackageCacheSize : long, in keptClosedContextCount : int) : void
		this.hostRuntimesPort = hostRuntimesPort;
		packageCacheManager.setMaxCacheSize(maxPackageCacheSize);
		this.keptClosedContextCount = keptClosedContextCount;
		
		taskManager = hostRuntimesPort.getTaskManager();
!!!477442.java!!!	terminate() : void
		System.exit(0);
		
		/* The dirty work of killing all running tasks will now be done by the
		 * shutdown hook, initialized in the constructor.
		 */
!!!477570.java!!!	isDetailedLoadCollision(inout taskDescriptor : TaskDescriptor) : boolean
		/* If the new task does not specify detailed load flag, no collision can
		 * occur.
		 */
		if (!taskDescriptor.getDetailedLoad()) {
			return false;
		}
		
		/* If there is any other task running with specified load flag, we have a
		 * collision.
		 */  
		try {
			for (TaskInterface task: runningTasks) {
				if (task.isDetailedLoad()) {
					return true;
				}
			}
		} catch (RemoteException e) {
			throw new AssertionError("Remote exception cannot be thrown on local call.");
		}
		
		return false;
!!!477698.java!!!	createTask(inout taskDescriptor : TaskDescriptor) : TaskInterface
		/* Check if we are initialized properly. */
		if (taskManager == null) {
			throw new IllegalStateException("Call \"initialize\" method before "
				+ "creating any task.");
		}
		
		/* Get the Software Repository service interface from the Task Manager.
		 * Maybe we should be more clever here and do not try to find it all the
		 * time... 
		 */ 
		SoftwareRepositoryInterface softwareRepository
			= (SoftwareRepositoryInterface) taskManager.serviceFind(
				SoftwareRepositoryService.SERVICE_NAME,
				Service.RMI_MAIN_IFACE
			);
		packageCacheManager.setSoftwareRepository(softwareRepository);
		
		/* Create the task instance. */
		TaskImplementation task;
		try {
			synchronized (runningTasks) {
				boolean measureDetailedLoad = taskDescriptor.getDetailedLoad()
					&& !isDetailedLoadCollision(taskDescriptor);
				task = new TaskImplementation(taskDescriptor, this, measureDetailedLoad);
				runningTasks.add(task);
			}
		} catch (TaskException e) {
			throw new HostRuntimeException(e);
		}
		return task;
!!!477826.java!!!	closeContext(in contextID : String) : void
		/* Check if there is a directory for given context. */
		String contextDir = rootDirectory
			+ File.separator + TASKS_BASE_DIR
			+ File.separator + contextID;
		if (!new File(contextDir).exists()) {
			throw new IllegalArgumentException("No task from context \"" + contextID 
				+ "\" was run on this Host Runtime.");
		}

		/* Check if there is no task running from given context. */
		synchronized (runningTasks) {
			for (TaskInterface task : runningTasks) {
				if (task.getContextID().equals(contextID)) {
					throw new IllegalArgumentException("Task \"" + task.getTaskID()
						+ "\" from context \"" + task.getContextID() + "\" is still running.");
				}
			}
		}
		
		/* Add the context to the queue of closed contexts if it is not already
		 * there. Delete its files if the queue is long enough,  
		 */
		synchronized (closedContexts) {
			for (String closedContextID: closedContexts) {
				if (closedContextID.equals(contextID)) {
					throw new IllegalArgumentException("Context \"" + contextID
						+ "\" was already closed.");
				}
			}
			closedContexts.add(contextID);
		}
		deleteOldClosedContexts();
!!!477954.java!!!	setMaxPackageCacheSize(in maxPackageCacheSize : long) : void
		packageCacheManager.setMaxCacheSize(maxPackageCacheSize);
!!!478082.java!!!	setKeptClosedContextCount(in keptClosedContextCount : int) : void
		this.keptClosedContextCount = keptClosedContextCount;
!!!478210.java!!!	getRunningTaskInterfaces() : TaskInterface
		synchronized (runningTasks) {
			return runningTasks.toArray(new TaskInterface[runningTasks.size()]);
		}		
