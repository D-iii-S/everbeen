class PersistentIDManager
!!!267522.java!!!	PersistentIDManager(inout dataDirectory : File)
		this.dataDirectory = dataDirectory;
!!!267650.java!!!	createInstance(inout dataDirectory : File) : PersistentIDManager
		// we need to have only our files in the directory -> create separate subdirectory
		File workDir = new File(dataDirectory,RESTORE_SUBDIRECTORY);
		// create instance and if the work directory existed already, run restore 
		PersistentIDManager idManager = new PersistentIDManager(workDir);
		if (workDir.exists()) { 
			restore(idManager);
		} else {
			if (!workDir.mkdirs()) {
				throw new IOException("Unable to create working directory :" + workDir.getPath());
			}
		}
		return idManager;
!!!267778.java!!!	getNext(inout clazz : Class<T>) : T
		Object[] value = idSet.get(clazz);
		Counter ctr = null;
		FileChannel channel = null;
		
		try {
			if (value == null) {
				ctr = new Counter(0);
				File f = new File(dataDirectory,clazz.getCanonicalName());
				if (!f.exists()) {
					f.createNewFile();
				}
				channel = new FileOutputStream(f).getChannel();
				idSet.put(clazz, new Object[]{ctr,f});
			} else {
				ctr = (Counter)value[0];
				channel = new FileOutputStream((File)value[1]).getChannel();
			}
	
			/*
			 * The log must be written before doing update of counter.
			 * With such behavior in the worst case we have updated log, but not the counter, so we will skip
			 * one (or more) numbers in restore phase but no duplicities will be created
			 */
			buf.putLong(ctr.getCount());
			buf.flip();
			while (buf.hasRemaining()) {
				channel.write(buf);
			}
			channel.force(false);
			channel.close();
			buf.clear();
			
			/*
			 * 
			 */
			T instance = clazz.newInstance();
			instance.setValue(ctr.getNext());
			return instance;
		} catch (Exception e) {
			e.printStackTrace();
			throw new IllegalStateException("Can't write value to file",e);
		}
!!!267906.java!!!	restore(inout instance : PersistentIDManager) : void
		ByteBuffer buf = ByteBuffer.allocateDirect(8);
		for (String keyName : instance.dataDirectory.list()) {
			File keyFile = new File(instance.dataDirectory,keyName);
			Class c = Class.forName(keyName);
			FileChannel channel = new FileInputStream(keyFile).getChannel();
			while (channel.read(buf) > 0);
			channel.close();
			if (buf.hasRemaining()) {
				throw new IOException("The file " + keyFile.getPath() + " is corrupted");
			}
			buf.rewind();
			Long value = buf.getLong() + 1;
			buf.clear();
			instance.idSet.put(c,new Object[]{new Counter(value),keyFile});
		}
