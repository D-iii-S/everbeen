class FileUploader
!!!528386.java!!!	FileUploader(inout handle : UploadHandle, in filename : String, in host : String, in port : int, inout rScript : boolean)
			super();
			this.filename = new String(filename);
			this.host = new String(host);
			this.port = port;
			this.handle = handle;
			this.rScript = rScript;
			setStatus(UploadStatus.INITIALIZING);
			setErrorMessages(new String[] {});
!!!528514.java!!!	setStatus(inout status : UploadStatus) : void
			uploadStatuses.put(handle, status);
!!!528642.java!!!	setErrorMessages(in errorMessages : String) : void
			uploadErrorMessages.put(handle, errorMessages);
!!!528770.java!!!	uploadAFile(inout tmpFile : File) : void
			byte[] buffer = new byte[UPLOAD_BUFFER_SIZE];
			int bytesRead;

			if (maxConnections > 0) {
				activeConnections++;
				connectionSemaphore.acquire();
			}

			File file;
			if (tmpFile == null) {
				file = new File(filename);
			} else {
				file = tmpFile;
			}
			Socket socket = new Socket(host, port);
			try {
				InputStream inputStream = new BufferedInputStream(socket
						.getInputStream(), UPLOAD_BUFFER_SIZE);
				OutputStream outputStream = new BufferedOutputStream(
						new FileOutputStream(file.getPath()),
						UPLOAD_BUFFER_SIZE);

				try {
					while ((bytesRead = inputStream.read(buffer)) != -1) {
						outputStream.write(buffer, 0, bytesRead);
					}
				} finally {
					inputStream.close();
					outputStream.close();
				}

				if (tmpFile == null) {
					// We're not having anything temporary for later validation
					setStatus(UploadStatus.ACCEPTED);
				}

				Task taskHandle = Task.getTaskHandle();
			    	if (taskHandle != null) {
			    	    Task.getTaskHandle().getTasksPort().checkPointReached(
						"upload-finish-" + handle.hashCode(), "1");
			    	} else {
			    	    Logger.logInfo("Unable to reach task's port, checkpoint not set.");
			    	}
				
				Logger.logInfo(
						"Results Repository thread: file stored.");
			} finally {
				socket.close();
				if (maxConnections > 0) {
					connectionSemaphore.release();
					activeConnections--;
				}
			}
!!!528898.java!!!	createTempFile() : File
			/*
			 * There is a bug in the Sun's JVM which causes the
			 * File.createTempFile call throw IOException with message "Access
			 * is denied" occasionally on Windows. We work around the bug by
			 * simply retrying the call multiple times. After a while we give
			 * up, to avoid hanging-up.
			 * 
			 * See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6325169
			 * for more information about the bug.
			 */
			File result = null;
			int tryCount = 0;
			boolean failed;
			IOException thrownException = null;

			do {
				failed = false;
				try {
					result = File.createTempFile("been-results-repository",
							null, new File(Database.getInstance().getTempDirectory()));
				} catch (IOException e) {
					failed = true;
					thrownException = e;
				}
				tryCount++;
			} while (failed && tryCount < MAX_CREATE_TEMP_FILE_TRY_COUNT);

			if (result != null) {
				return result;
			} else {
				throw thrownException;
			}
!!!529026.java!!!	unpackAndValidateRScript(in path : String) : String
			
			ArrayList<String> errMessages = new ArrayList<String>();
			
			Logger.logDebug(
					"Unpacking " + path + " into " + path + TEMP_DIR_EXT + ".");
			try {
				if (!(new File(path + TEMP_DIR_EXT).mkdir())) {
					throw new IOException("Couldn't create directory - " + path
							+ TEMP_DIR_EXT + ".");
				}
				Zipper.unzipFile(path, path + TEMP_DIR_EXT);
				File[] directoryList;
				directoryList = new File(path + TEMP_DIR_EXT).listFiles();
				for (File file : directoryList) {
					String filename = file.getName();
					if (!file.isFile()) {
						errMessages.add("Package cannot contain directory.");
					}
					if (!filename.equals("description") &&
							!filename.matches(".*\\.r") &&
							!filename.matches(".*\\.hlp")) {
								errMessages.add("Invalid item found in package : \"" + filename  
										+ "\", only 'description', '*.r', '*.hlp' are allowed");
					}
				}
			} catch (IOException e) {
				errMessages.add("I/O error registering package - see Results Repository stderr for stack trace");
				e.printStackTrace();
			}
			return errMessages.toArray(new String[] {});
!!!529154.java!!!	run() : void

			setStatus(UploadStatus.UPLOADING);

			try {
				if (rScript) {
					File tempFile = createTempFile();
					File tomoveFile = null;
					try {
						uploadAFile(tempFile);
						String[] errorMessages = unpackAndValidateRScript(tempFile.getPath());
						if (errorMessages.length > 0) {
							throw new RPackageUploadException(
									"Tried to upload invalid package "
										+ "(host = " + host + ", port = " + port + ").",
									errorMessages);
						}

						/*
						 * Try to move the file. If the move fails, bail
						 * everything and delete the temp file. The file name
						 * won't be reused and is lost forever.
						 */
						File packageFile = new File(getDatabasePath()
								+ File.separator + RSCRIPTS_DIRECTORY
								+ File.separator + filename);

						tomoveFile = new File(tempFile.getPath() + TEMP_DIR_EXT);

						if (!tomoveFile.renameTo(packageFile)) {
							throw new IOException("Cant't rename file \""
									+ tomoveFile.getPath() + "\" to \""
									+ packageFile.getPath() + "\".");
						}

						rManager.sourceOnePackageScript("");
						rManager.reloadRFunctionsHelp();

						Logger.logInfo("Successfully registered R package \""
									+ packageFile.getPath() + "\".");
						setStatus(UploadStatus.ACCEPTED);

						/*
						 * After all operations finish (either succesfully or
						 * due to some error), delete the temporary file if it
						 * still exists.
						 */
					} finally {
						eraseDirectoryRecursively(tempFile);
						eraseDirectoryRecursively(tomoveFile);
					}

				} else {
					uploadAFile(null);
				}
			} catch (UnknownHostException e) {
				e.printStackTrace();
				Logger.logError("Upload error: " + e.getMessage() + ".");
				setStatus(UploadStatus.ERROR);
			} catch (RPackageUploadException e) {
				String[] errorMessages = e.getErrorMessages();
				Logger.logError(
						e.getMessage() + " " + Integer.toString(errorMessages.length)
								+ " messages reported:");
				for (String errorMessage : errorMessages) {
					Logger.logError("  " + errorMessage);
				}
				setErrorMessages(errorMessages);
				setStatus(UploadStatus.REJECTED);
			} catch (IOException e) {
				e.printStackTrace();
				Logger.logError("Upload error: " + e.getMessage() + ".");
				setStatus(UploadStatus.ERROR);
			} catch (ResultsRepositoryException e) {
				e.printStackTrace();
				Logger.logError("Package registered - error sourcing into R: " + e.getMessage() + ".");
				setStatus(UploadStatus.ERROR);			
			} catch (InterruptedException e) {
				e.printStackTrace();
				Logger.logError("Upload error: " + e.getMessage() + ".");
				setStatus(UploadStatus.ERROR);
			} finally {
				try {
				    	Task taskHandle = Task.getTaskHandle();
				    	if (taskHandle != null) {
				    	    Task.getTaskHandle().getTasksPort().checkPointReached(
							"upload-finish-" + handle.hashCode(), "1");
				    	} else {
				    	    Logger.logInfo("Unable to reach task's port, checkpoint not set.");
				    	}
				} catch (RemoteException e) {
					Logger.logError(
						"Error comunicating with Host Runtime tasks port - unable to set checkpoint.");
				}
			}
