class SchedulerEntry
!!!233858.java!!!	SchedulerEntry(inout data : Serializable, inout date : Date, inout listener : ScheduledJobListener)
    	this.data = data;
        this.listener = listener;
        Calendar alarm = Calendar.getInstance();
        alarm.setTime(date);
        minutes = new int[] { alarm.get(Calendar.MINUTE) };
        hours = new int[] { alarm.get(Calendar.HOUR_OF_DAY) };
        daysOfMonth = new int[] { alarm.get(Calendar.DAY_OF_MONTH) };
        months = new int[] { alarm.get(Calendar.MONTH) };
        year = alarm.get( Calendar.YEAR );
        isRepeating = false;
        isRelative = false;
        alarmTime = date.getTime();
        checkAlarmTime();
!!!233986.java!!!	SchedulerEntry(inout data : Serializable, in minutesDelay : int, inout isRepeating : boolean, inout listener : ScheduledJobListener)
    	this.data = data;
    	if (minutesDelay < 1) {
            throw new PastDateException();
        }
        minutes = new int[] { minutesDelay };
        this.listener = listener;
        this.isRepeating = isRepeating;
        isRelative = true;
        updateAlarmTime();
!!!234114.java!!!	SchedulerEntry(inout data : Serializable, in minute : int, in hour : int, in dayOfMonth : int, in month : int, in dayOfWeek : int, in year : int, inout listener : ScheduledJobListener)
        this(data, new int[]{minute}, new int[]{hour}, new int[]{dayOfMonth}, new int[]{month},
                new int[]{dayOfWeek}, year, listener);
!!!234242.java!!!	SchedulerEntry(inout data : Serializable, in minutes : int, in hours : int, in daysOfMonth : int, in months : int, in daysOfWeek : int, in year : int, inout listener : ScheduledJobListener)
        
    	this.data = data;
    	this.minutes = minutes;
        this.hours = hours;
        this.daysOfMonth = daysOfMonth;
        this.months = months;
        this.daysOfWeek = daysOfWeek;
        this.year = year;
        this.listener = listener;
        this.isRepeating = (year == -1);
        this.isRelative = false;
        
        updateAlarmTime();
        checkAlarmTime();
!!!234370.java!!!	isRepeating() : boolean
		return isRepeating;
!!!234498.java!!!	getData() : Serializable
		return data;
!!!234626.java!!!	checkAlarmTime() : void
        long delay = alarmTime - System.currentTimeMillis();
        
        if (delay <= 100) {
            throw new PastDateException();
        }
!!!234754.java!!!	startScheduledJob() : void
        listener.runJob(this);
!!!234882.java!!!	updateAlarmTime() : void
    	updateAlarmTime(System.currentTimeMillis());
!!!235010.java!!!	getAlarmTime() : long
		return alarmTime;
!!!235138.java!!!	updateAlarmTime(in time : long) : void
    	 Calendar now = Calendar.getInstance();
    	 now.setTime(new Date(time));
         
         if (isRelative) {
             // relative only uses minutes field, with only a single value (NOT -1)
             alarmTime = time + (minutes[0] * 60000);
             return;
         }
         
         Calendar alarm = (Calendar)now.clone();
         alarm.set( Calendar.SECOND, 0 );
         
         //
         // the updates work in a cascade -- if next minute value is in the
         // following hour, hour is incremented.  If next valid hour value is
         // in the following day, day is incremented, and so on.
         //
         
         // increase alarm minutes
         int current = alarm.get( Calendar.MINUTE );
         int offset = 0;
         // force increment at least to next minute
         offset = getOffsetToNext( current, minMinute, maxMinute, minutes );
         alarm.add( Calendar.MINUTE, offset );
         
         // update alarm hours if necessary
         current = alarm.get( Calendar.HOUR_OF_DAY );  // (as updated by minute shift)
         offset = getOffsetToNextOrEqual( current, minHour, maxHour, hours );
         alarm.add( Calendar.HOUR_OF_DAY, offset );
         
         //
         // If days of month AND days of week are restricted, we take whichever match
         // comes sooner.
         // If only one is restricted, take the first match for that one.
         // If neither is restricted, don't do anything.
         //
         if( daysOfMonth[0] != -1 && daysOfWeek[0] != -1 )
         {
             // BOTH are restricted - take earlier match
             Calendar dayOfWeekAlarm = (Calendar)alarm.clone();
             updateDayOfWeekAndMonth( dayOfWeekAlarm );
             
             Calendar dayOfMonthAlarm = (Calendar)alarm.clone();
             updateDayOfMonthAndMonth( dayOfMonthAlarm );
             
             // take the earlier one
             if( dayOfMonthAlarm.getTime().getTime() < dayOfWeekAlarm.getTime().getTime() )
             {
                 alarm = dayOfMonthAlarm;
             }
             else
             {
                 alarm = dayOfWeekAlarm;
             }
         }
         else if( daysOfWeek[0] != -1 ) // only dayOfWeek is restricted
         {
             // update dayInWeek and month if necessary
             updateDayOfWeekAndMonth( alarm );
         }
         else if( daysOfMonth[0] != -1 ) // only dayOfMonth is restricted
         {
             // update dayInMonth and month if necessary
             updateDayOfMonthAndMonth( alarm );
         }
         // else if neither is restricted (both[0] == -1), we don't need to do anything.
         
         
         alarmTime = alarm.getTime().getTime();
         lastUpdateTime = System.currentTimeMillis();
!!!235266.java!!!	updateDayOfMonthAndMonth(inout alarm : Calendar) : void
        int currentMonth = alarm.get( Calendar.MONTH );
        int currentDayOfMonth = alarm.get( Calendar.DAY_OF_MONTH );
        int offset = 0;
        
        // loop until we have a valid day AND month (if current is invalid)
        while( !isIn(currentMonth, months) || !isIn(currentDayOfMonth, daysOfMonth) )
        {
            // if current month is invalid, advance to 1st day of next valid month
            if( !isIn(currentMonth, months) )
            {
                offset = getOffsetToNextOrEqual( currentMonth, minMonth, maxMonth, months );
                alarm.add( Calendar.MONTH, offset );
                alarm.set( Calendar.DAY_OF_MONTH, 1 );
                currentDayOfMonth = 1;
            }
            
            // advance to the next valid day of month, if necessary
            if( !isIn(currentDayOfMonth, daysOfMonth) )
            {
                int maxDayOfMonth = alarm.getActualMaximum( Calendar.DAY_OF_MONTH );
                offset = getOffsetToNextOrEqual( currentDayOfMonth, minDayOfMonth, maxDayOfMonth, daysOfMonth );
                alarm.add( Calendar.DAY_OF_MONTH, offset );
            }
            
            currentMonth = alarm.get( Calendar.MONTH );
            currentDayOfMonth = alarm.get( Calendar.DAY_OF_MONTH );
        }
!!!235394.java!!!	updateDayOfWeekAndMonth(inout alarm : Calendar) : void
        int currentMonth = alarm.get( Calendar.MONTH );
        int currentDayOfWeek = alarm.get( Calendar.DAY_OF_WEEK );
        int offset = 0;
        
        // loop until we have a valid day AND month (if current is invalid)
        while( !isIn(currentMonth, months) || !isIn(currentDayOfWeek, daysOfWeek) )
        {
            // if current month is invalid, advance to 1st day of next valid month
            if( !isIn(currentMonth, months) )
            {
                offset = getOffsetToNextOrEqual( currentMonth, minMonth, maxMonth, months );
                alarm.add( Calendar.MONTH, offset );
                alarm.set( Calendar.DAY_OF_MONTH, 1 );
                currentDayOfWeek = alarm.get( Calendar.DAY_OF_WEEK );
            }
            
            // advance to the next valid day of week, if necessary
            if( !isIn(currentDayOfWeek, daysOfWeek) )
            {
                offset = getOffsetToNextOrEqual( currentDayOfWeek, minDayOfWeek, maxDayOfWeek, daysOfWeek );
                alarm.add( Calendar.DAY_OF_YEAR, offset );
            }
            
            currentDayOfWeek = alarm.get( Calendar.DAY_OF_WEEK );
            currentMonth = alarm.get( Calendar.MONTH );
        }
!!!235522.java!!!	getOffsetToNext(in current : int, in min : int, in max : int, in values : int) : int
        int offset = 0;
        
        // find the distance to the closest valid value > current (wrapping if neccessary)
        
        // {-1} means *  -- offset is 1 because current++ is valid value
        if (values[0] == -1 )
        {
            offset = 1;
        }
        else
        {
            // need to wrap
            if( current >= last(values) )
            {
                int next = values[0];
                offset = (max-current+1) + (next-min);
            }
            else // current < max(values) -- find next valid value after current
            {
                findvalue:
                for( int i=0; i<values.length; i++ )
                {
                    if( current < values[i] )
                    {
                        offset = values[i] - current;
                        break findvalue;
                    }
                }
            } // end current < max(values)
        }
        
        return offset;
!!!235650.java!!!	getOffsetToNextOrEqual(in current : int, in min : int, in max : int, in values : int) : int
        int offset = 0;
        int[] safeValues = null;
        
        // find the distance to the closest valid value >= current (wrapping if necessary)
        
        // {-1} means *  -- offset is 0 if current is valid value
        if (values[0] == -1 || isIn(current, values) )
        {
            offset = 0;
        }
        else
        {
            safeValues = discardValuesOverMax( values, max );
            
            // need to wrap
            if( current > last(safeValues) )
            {
                int next = safeValues[0];
                offset = (max-current+1) + (next-min);
            }
            else // current <= max(values) -- find next valid value
            {
                findvalue:
                for( int i=0; i<values.length; i++ )
                {
                    if( current < safeValues[i] )
                    {
                        offset = safeValues[i] - current;
                        break findvalue;
                    }
                }
            } // end current <= max(values)
        }
        
        return offset;
!!!235778.java!!!	isIn(in find : int, in values : int) : boolean
        if( values[0] == -1 )
        {
            return true;
        }
        else
        {
            for( int i=0; i<values.length; i++ )
            {
                if( find == values[i] )
                    return true;
            }
            return false;
        }
!!!235906.java!!!	last(in intArray : int) : int
        return intArray[ intArray.length - 1 ];
!!!236034.java!!!	discardValuesOverMax(in values : int, in max : int) : int
        int[] safeValues = null;
        for( int i=0; i<values.length; i++ )
        {
            if( values[i] > max )
            {
                safeValues = new int[i];
                System.arraycopy( values, 0, safeValues, 0, i );
                return safeValues;
            }
        }
        return values;
!!!236162.java!!!	arrToString(in intArray : int) : String
        if( intArray == null )
            return "null";
        if( intArray.length == 0 )
            return "{}";
        
        String s = "{";
        for( int i=0; i<intArray.length-1; i++ )
        {
            s += intArray[i] + ", ";
        }
        s += intArray[intArray.length-1] + "}";
        
        return s;
!!!236290.java!!!	compareTo(inout other : SchedulerEntry) : int
        if (alarmTime < other.alarmTime)
            return -1;
        else if (alarmTime > other.alarmTime)
            return 1;
        else // alarmTime == other.alarmTime
        {
            if( lastUpdateTime < other.lastUpdateTime )
                return -1;
            else if( lastUpdateTime > other.lastUpdateTime)
                return 1;
            else
                return 0;    
        }
!!!236418.java!!!	equals(inout obj : Object) : boolean
        SchedulerEntry entry = null;
        
        if( obj == null || !(obj instanceof SchedulerEntry) )
            return false;
        
        entry = (SchedulerEntry)obj;
        return (   data.equals(entry.data)
                // We dont need this: && alarmTime== entry.alarmTime
                && isRelative == entry.isRelative
                && isRepeating == entry.isRepeating
                && Arrays.equals(minutes, entry.minutes)
                && Arrays.equals(hours, entry.hours)
                && Arrays.equals(daysOfMonth, entry.daysOfMonth)
                && Arrays.equals(months, entry.months)
                && Arrays.equals(daysOfWeek, entry.daysOfWeek) );
!!!236546.java!!!	toString() : String
        if (year != -1) {
            return "Alarm at " + new Date(alarmTime);
        }
        StringBuffer sb = new StringBuffer("Alarm params");
        sb.append(" minute="); sb.append( arrToString(minutes) );
        sb.append(" hour="); sb.append( arrToString(hours) );
        sb.append(" dayOfMonth="); sb.append( arrToString(daysOfMonth) );
        sb.append(" month="); sb.append( arrToString(months) );
        sb.append(" dayOfWeek="); sb.append( arrToString(daysOfWeek) );
        sb.append(" (next alarm date=" + new Date(alarmTime) + ")");
        sb.append(data);
        return sb.toString();
!!!236674.java!!!	main(in args : String) : void
        
        System.out.println( "GETTING OFFSETS" );
        
        System.out.println( "getOffsetToNext(3, 0, 11, new int[]{3,5,7,9}) = " +
                getOffsetToNext(3, 0, 11, new int[]{3,5,7,9}) );
        System.out.println( "getOffsetToNextOrEqual(3, 0, 11, new int[]{3,5,7,9}) = " +
                getOffsetToNextOrEqual(3, 0, 11, new int[]{3,5,7,9}) );
        
        System.out.println();
        System.out.println( "getOffsetToNext(9, 0, 11, new int[]{3,5,7,9}) = " +
                getOffsetToNext(9, 0, 11, new int[]{3,5,7,9}) );
        System.out.println( "getOffsetToNextOrEqual(9, 0, 11, new int[]{3,5,7,9}) = " +
                getOffsetToNextOrEqual(9, 0, 11, new int[]{3,5,7,9}) );
        
        System.out.println();
        System.out.println( "getOffsetToNext(0, 0, 11, new int[]{0}) = " +
                getOffsetToNext(0, 0, 11, new int[]{0}) );
        System.out.println( "getOffsetToNextOrEqual(0, 0, 11, new int[]{0}) = " +
                getOffsetToNextOrEqual(0, 0, 11, new int[]{0}) );
        
        System.out.println();
        System.out.println( "getOffsetToNext(5, 0, 11, new int[]{5}) = " +
                getOffsetToNext(5, 0, 11, new int[]{5}) );
        System.out.println( "getOffsetToNextOrEqual(5, 0, 11, new int[]{5}) = " +
                getOffsetToNextOrEqual(5, 0, 11, new int[]{5}) );
        
        System.out.println();
        System.out.println( "getOffsetToNext(0, 0, 11, new int[]{-1}) = " +
                getOffsetToNext(0, 0, 11, new int[]{-1}) );
        System.out.println( "getOffsetToNextOrEqual(0, 0, 11, new int[]{-1}) = " +
                getOffsetToNextOrEqual(0, 0, 11, new int[]{-1}) );
        
        System.out.println();
        
        System.out.println();
        System.out.println( "discardValuesOverMax(new int[]{0,1,2,3,4,5,6}, 4)) = " + 
                arrToString(discardValuesOverMax(new int[]{0,1,2,3,4,5,6}, 4)) );
        System.out.println( "discardValuesOverMax(new int[]{0,1,2,3,4,5,6}, 6)) = " + 
                arrToString(discardValuesOverMax(new int[]{0,1,2,3,4,5,6}, 6)) );
        System.out.println( "discardValuesOverMax(new int[]{0,1,2,3,4,5,6}, 0)) = " + 
                arrToString(discardValuesOverMax(new int[]{0,1,2,3,4,5,6}, 0)) );
        System.out.println( "discardValuesOverMax(new int[]{0,1,2,3,4,5,6}, 7)) = " + 
                arrToString(discardValuesOverMax(new int[]{0,1,2,3,4,5,6}, 7)) );
