class JPFPluginManager
!!!130178.java!!!	JPFPluginManager(inout manager : PluginManagerLocalInterface, inout bootProperties : ExtendedProperties, in defaultPluginsDirectory : String, in workingDirectory : String, inout restoreRootDirectory : File)
		
		this.localManager = manager;
		this.bootProperties = bootProperties;
		this.pluginsRepository = null;
		this.defaultPluginsDirectory = defaultPluginsDirectory;
		this.workingDirectory = workingDirectory;
		this.restoreRootDir = new File(restoreRootDirectory, RESTORE_SUBDIRECTORY);
		
		if (restoreRootDir.exists()) {
			restore(this);
		} else {
			if (!restoreRootDir.mkdirs()) {
				throw new ComponentInitializationException("Unable to create working directory: " + restoreRootDir.getPath());
			}
		}
		
		createPluginsRepository();
		deployCorePlugin();
		deployDefaultPlugins();
		createPluginManager();

		refreshRegistry(true);
!!!130306.java!!!	getBootProperties() : ExtendedProperties
		
		return bootProperties;
!!!130818.java!!!	getAvailablePlugins() : BeenPluginDescriptor
		
		Collection extensions = pluginManager.getRegistry().getExtensionPoint(getCorePluginName(), getExtensionPointID()).getConnectedExtensions();
		BeenPluginDescriptor[] plugins = new BeenPluginDescriptor[extensions.size()];
		
		int i = 0;
		
		for (Iterator iter = extensions.iterator(); iter.hasNext(); ) {
			try {
				Extension ext = (Extension) iter.next();
				final String jpfPluginID = ext.getDeclaringPluginDescriptor().getId();
				final PEID pluginID = new PEID(jpfPluginID);
				final BeenPluginDescriptor desc = new BeenPluginDescriptor(pluginID);
				desc.setName(getPluginName(pluginID));
				if (ext.getDeclaringPluginDescriptor().getDocumentation() != null) {
					desc.setDescription(ext.getDeclaringPluginDescriptor().getDocumentation().getText());
				}
				String pluginVersion = ext.getDeclaringPluginDescriptor().getVersion().toString();
				if (! StringUtils.isEmpty(pluginVersion)) {
					desc.setVersion(pluginVersion);
				}
				plugins[i++] = desc;
			} catch (ApplicationException e) {
				// skip the problematic plug-in
				continue;
			}
		}
		
		return plugins;
!!!130946.java!!!	getPluginName(inout pluginID : PEID) : String
		PluginDescriptor desc;
		try {
			desc = pluginManager.getPlugin((String) pluginID.value()).getDescriptor();
		} catch (PluginLifecycleException e) {
			throw new BenchmarkManagerException(e);
		}
		PluginAttribute attName = desc.getAttribute("pluginName");
		if (attName == null || StringUtils.isEmpty(attName.getValue())) {
			return (String)pluginID.value();
		} else {
			return attName.getValue();
		}
!!!131074.java!!!	getPluginsRepository() : File
		
		return pluginsRepository;
!!!131202.java!!!	getDefaultPluginsDirectory() : String
		
		return defaultPluginsDirectory;
!!!131330.java!!!	getWorkingDirectory() : String
		
		return workingDirectory;
!!!131458.java!!!	getLocalManager() : PluginManagerLocalInterface
		
		return localManager;
!!!131586.java!!!	createConfigurator(inout pluginID : PEID) : Configurator
		String id = (String) pluginID.value();
		
		return (Configurator) loadClassForPlugin(id, "configurator");
!!!131714.java!!!	createGenerator(inout pluginID : PEID) : TaskGenerator
		
		String id = (String) pluginID.value();
		return (TaskGenerator) loadClassForPlugin(id, "generator");
!!!131842.java!!!	createVersionProvider(inout pluginID : PEID) : VersionProvider
		
		String id = (String) pluginID.value();
		VersionProvider p = (VersionProvider) loadClassForPlugin(id, "versionprovider");
		
		try {
			p.setLocalManager(localManager);
		} catch (Exception e) {
			throw new ApplicationException("Unable to initialize VersionProvider.", e);
		}
		
		return p;
!!!131970.java!!!	loadClassForPlugin(in pluginID : String, in paramName : String) : Object
		
		try {
			PluginDescriptor pluginDesc = pluginManager.getPlugin(pluginID).getDescriptor();
			// only one extension is allowed for plug-in on extension point
			Extension extension = null;
			for (Iterator iter = pluginDesc.getExtensions().iterator(); iter.hasNext(); ) {
				Extension ext = (Extension) iter.next();
				if (ext.getExtendedPointId().equals(getExtensionPointID())) {
					extension = ext;
					break;
				}
			}
			
			if (extension == null) {
				throw new BenchmarkManagerException("Plugin has no extension for '" + getExtensionPointID() + "' extension point");
			}
			
			final String className = extension.getParameter(paramName).valueAsString();
			PluginClassLoader pluginLoader = pluginManager.getPluginClassLoader(pluginDesc);
			Class instanceClass = pluginLoader.loadClass(className);
			return instanceClass.newInstance();
		} catch (Exception e) {
			throw new ApplicationException(e);
		}
!!!132098.java!!!	updateRejectionList(inout rejected : List< String >) : void
		
		// get contexts for plug-ins
		for (String id : rejected) {
			try {
				URL rejectedURL = pluginManager.getPathResolver().getRegisteredConext(id);
				rejectedPlugins.add(rejectedURL);
			} catch (IllegalArgumentException e ) {
				localManager.logDebug("Unable to get context for damaged plugin '" + id + "'");
			}
		}
		
		// unregister damaged plug-ins
		pluginManager.getRegistry().unregister(rejected.toArray(new String[rejected.size()]));
		
		/*
		 * URLClassLoader keeps locking jar files, but hopefully it will be garbage-collected 
		 * once and we will be able to delete the file.
		 *   
		 * Go through the files, check them and try to delete them, then remove the entry.
		 */
		List< URL > successfullyDeleted = new LinkedList< URL >();
		for (URL location : rejectedPlugins) {
			String fname = location.getFile();
			String pluginFile = fname.substring(0, fname.length() - 2);
			if (deleteRejectedURL(location)) {
				localManager.logInfo("Deleted invalid plugin file: " + pluginFile);
				successfullyDeleted.add(location);
			} else {
				localManager.logInfo("Unable to delete invalid plugin file: " + pluginFile);
			}
		}
		
		rejectedPlugins.removeAll(successfullyDeleted);
		
		try {
			saveRejectionList();
		} catch (IOException e) {
			throw new ComponentInitializationException(e);
		}
!!!132354.java!!!	validatePlugins() : void
			
		integrityReport = new PluginsIntegrityReport();
		
		final List<String> pluginsToDisable = new LinkedList<String>();
		
		Collection extensions = pluginManager.getRegistry().getExtensionPoint(getCorePluginName(), getExtensionPointID()).getConnectedExtensions();
		for (Iterator iter = extensions.iterator(); iter.hasNext(); ) {
			Extension ext = (Extension) iter.next();
			String errorMessage = validatePlugin(ext);
			final String pluginID = ext.getDeclaringPluginDescriptor().getId();
			String pluginName;
			try {
				// Try to fill in the plug-in name
				pluginName = getPluginName(new PEID(pluginID));
			} catch (ApplicationException e) {
				/* As we are reporting plug-in status, the previous call may fail
				 * ignore exception and use pluginID instead
				 */
				pluginName = pluginID;
				if (errorMessage == null) {
					errorMessage = e.getMessage();
				}
			} catch (RuntimeException e) {
				// JPF throws IllegalArgumentException when plug-in is disabled
				pluginName = pluginID;
				if (errorMessage == null) {
					errorMessage = e.getMessage();
				}
				
			}
			addIntegrityEntry(pluginName, errorMessage);
			if (errorMessage != null) {
				pluginsToDisable.add(pluginID);
			}
		}
	
		// unregister and try to delete invalid plug-ins
		updateRejectionList(pluginsToDisable);

		localManager.logDebug(integrityReport.toString());
!!!132482.java!!!	refreshRegistry(inout firstTime : boolean) : void

		localManager.logInfo("Refreshing plug-in registry");
		
		PluginRegistry pluginRegistry = pluginManager.getRegistry();
		
		DefaultPluginsCollector collector = new DefaultPluginsCollector();
		try {
			collector.configure(bootProperties);
		} catch (Exception e) {
			throw new ComponentInitializationException(e);
		}
		Collection locations = collector.collectPluginLocations();
		List< PluginLocation > newLocations = new ArrayList< PluginLocation >();
		
		// Remove entries that are in the rejection list
		for (Iterator iter = locations.iterator(); iter.hasNext();) {
			PluginLocation element = (PluginLocation) iter.next();
			if (! rejectedPlugins.contains(element.getContextLocation())) {
				newLocations.add(element);
			}
		}
		
		/*
		 * We will check old plug-ins for existence only when CORE_PLUGIN is available to JPF 
		 * (i.e. when we are not running for the first time)
		 */
		if (pluginManager.getRegistry().isPluginDescriptorAvailable(getCorePluginName())) {
			Collection extensions = pluginManager.getRegistry().getExtensionPoint(getCorePluginName(), getExtensionPointID()).getConnectedExtensions();
			ArrayList< String > toRemove = new ArrayList< String >();
			
			for (Iterator iter = extensions.iterator(); iter.hasNext(); ) {
				Extension ext = (Extension) iter.next();
				final String pluginId = ext.getDeclaringPluginDescriptor().getId();
				if (!pluginRegistry.isPluginDescriptorAvailable(pluginId)) {
					// plug-in has been damaged or removed
					pluginManager.deactivatePlugin(pluginId);
					localManager.logWarning("Plug-in '" + pluginId + "' is not available. Deactivating.");
					toRemove.add(pluginId);
				}
			}
			
			// remove damaged plug-ins from registry
			updateRejectionList(toRemove);
		}

		// register new entries & activate them afterwards
		try {
			PluginLocation[] locationArray = newLocations.toArray(new PluginLocation[newLocations.size()]);
			localManager.logInfo("Found " + locationArray.length + " plugins in repository");
			pluginManager.publishPlugins(locationArray);
			
			for (Iterator iter = pluginManager.getRegistry().getPluginDescriptors().iterator(); iter.hasNext();) {
				PluginDescriptor plugin = (PluginDescriptor) iter.next();
				if (!pluginManager.isPluginActivated(plugin)) {
					localManager.logInfo("Activated: " + plugin.getId());
					pluginManager.activatePlugin(plugin.getId());
				}
			}
		} catch (JpfException e) {
			throw new ComponentInitializationException(e);
		}
		
		// Check if we have core plug-in available - if not, we will not be able to continue
		if (!pluginManager.getRegistry().isPluginDescriptorAvailable(getCorePluginName())) {
			IntegrityCheckReport report  = pluginManager.getRegistry().checkIntegrity(pluginManager.getPathResolver());
			
			// let's blame JPF
			String reason = "JPF library error";

			// is at least the plug-in file available in the registry?
			if (!new File(pluginsRepository, getCorePluginFileName()).exists()) {

				reason = "Core plugin file (" + getCorePluginFileName() + ") not found in plugins repository: " + pluginsRepository.getAbsolutePath(); 
			}
			// try to get reason from report
			for (Iterator iter = report.getItems().iterator(); iter.hasNext();) {
				ReportItem item = (ReportItem) iter.next();
				if (item.getSource() != null && getCorePluginName().equals(item.getSource().getId()) && 
						(item.getSeverity() == ReportItem.SEVERITY_ERROR || item.getSeverity() == ReportItem.SEVERITY_WARNING)) {
					reason = item.getMessage();
					break;
				}
			}
			localManager.logFatal("Core plugin is not available: " + reason);
			throw new ComponentInitializationException("Core plugin is not available. Remaining plug-ins will not work.\n" +
					"Please check integrity of the core plug-in and restart component\n" + 
					"Reason: " + reason);
		}

		// perform validation and disable invalid plug-ins
		validatePlugins();
!!!132610.java!!!	registerPlugin(inout sourceFile : File) : void

		DefaultPluginsCollector collector = new DefaultPluginsCollector();
		ExtendedProperties props = new  ExtendedProperties();
		props.putAll(this.bootProperties);
		// we will scan only the new file
		props.put("org.java.plugin.boot.pluginsRepositories", sourceFile.getAbsolutePath());
		
		try {
			collector.configure(props);
		} catch (Exception e) {
			localManager.logError("Unable to configure plugins collector: " + e.getMessage());
			throw new BenchmarkManagerException("Unable to deploy plugin");
		}

		Collection collectedLocations = collector.collectPluginLocations();
		
		// we have no new entry -> probably some strange file
		if (collectedLocations.isEmpty()) {
			throw new BenchmarkManagerException("Plugin file is not a ZIP/JAR file or plugin is missing the descriptor");
		}
		
		// OK, detected the file, let's validate it
		PluginLocation loc = (PluginLocation)collectedLocations.iterator().next();
		try {
			pluginManager.getRegistry().readManifestInfo(loc.getManifestLocation());
		} catch (ManifestProcessingException e) {
			throw new BenchmarkManagerException("Plugin descriptor is invalid");
		}
		
		// copy file to repository and refresh
		Copy.copyToDir(sourceFile.getAbsolutePath(),getPluginsRepository().getAbsolutePath());
		refreshRegistry(false);
		File pluginFile = new File(getPluginsRepository().getAbsolutePath(),sourceFile.getName());

		// check if the plug-in was rejected
		if (isRejected(pluginFile)) {
			throw new BenchmarkManagerException("Plugin is missing required parameters or classes");
		}
		
		// we have new entry not in error -> plug-in is OK
		localManager.logInfo("New plugin installed: " + sourceFile.getName());
!!!132738.java!!!	createPluginsRepository() : void
		
		pluginsRepository = new File(workingDirectory, PLUGIN_REPOSITORY_ROOT);
		// create plugins directory if not exists
		if (!pluginsRepository.exists()) {
			if (!pluginsRepository.mkdir()) {
				throw new ComponentInitializationException("Unable to create plugins directory: " + 
						pluginsRepository.getAbsolutePath());
			}
		}
		
		// add repository key for the DefaultPluginsCollector
		bootProperties.put("org.java.plugin.boot.pluginsRepositories", pluginsRepository.getAbsolutePath());
!!!132866.java!!!	deployCorePlugin() : void
		// Copy JAR file with the core plug-in
		final String pluginCoreFile = defaultPluginsDirectory + File.separator + getCorePluginFileName();
		if (!new File(pluginsRepository, getCorePluginFileName()).exists()) {
			try {
				Copy.copyToDir(pluginCoreFile, pluginsRepository.getAbsolutePath());
			} catch (AntTaskException e) {
				localManager.logFatal("Core plugin not found in package: " + e.getMessage());
				throw new ComponentInitializationException("Core plugin is not available!\n" + 
						" Plug-in system will not work. Check package integrity.\n" + e.getMessage());
			}
		}
!!!132994.java!!!	deployDefaultPlugins() : void
		// If set, copy default plug-ins to repository
		final File defaultDir = new File(defaultPluginsDirectory);
		for (String fileName : defaultDir.list()) {
			try {
				// do not overwrite existing plug-ins
				if (new File(pluginsRepository, fileName).exists()) {
					continue;
				}
				
				// otherwise copy default plug-in to repository
				Copy.copyToDir(defaultPluginsDirectory + File.separator + fileName, pluginsRepository.getAbsolutePath());
			} catch (AntTaskException e) {
				localManager.logWarning("Error copying default plug-in " + fileName + " to the repository: " + e.getMessage());
			}
		}
!!!133122.java!!!	createPluginManager() : void

		pluginManager = ObjectFactory.newInstance(bootProperties).createManager();
!!!133250.java!!!	isRejected(inout pluginFile : File) : boolean
		
		try {
			return rejectedPlugins.contains(new URL("jar:" + IoUtil.file2url(pluginFile).toExternalForm() + "!/"));
		} catch (MalformedURLException e) {
			assert false : "Unable to convert plugin file to URL";
		}
		
		return true;
!!!133378.java!!!	addIntegrityEntry(in pluginID : String, in errorMessage : String) : void
		integrityReport.addErrorEntry(pluginID, errorMessage, 
				errorMessage == null ? IntegrityErrorSeverity.OK : IntegrityErrorSeverity.ERROR);
!!!133506.java!!!	getIntegrityReport() : PluginsIntegrityReport
		
		return integrityReport;
!!!133634.java!!!	deleteRejectedURL(inout location : URL) : boolean
		String fileName = location.getFile();
		// remove "file:/" prefix and "/!" suffix because JarURL returns file like that
		fileName = fileName.substring(6,fileName.length()-2);
		File pluginFile = new File(fileName);
		if (pluginFile.exists()) {
			return pluginFile.delete();
		}
		
		return false;
!!!133762.java!!!	saveRejectionList() : void
		BufferedWriter writer = new BufferedWriter(new FileWriter(new File(restoreRootDir,REJECTED_PLUGINS_FILE_NAME)));
		for (URL url : rejectedPlugins) {
			writer.write(url.toExternalForm());
			writer.newLine();
		}
		writer.flush();
		writer.close();
!!!133890.java!!!	restore(inout instance : JPFPluginManager) : void
		
		instance.localManager.logDebug("Restoring plugins rejections list");
		File rejected = new File(instance.restoreRootDir, REJECTED_PLUGINS_FILE_NAME);
		try {
			BufferedReader reader = new BufferedReader(new FileReader(rejected));
			String rejectURL;
			while ((rejectURL = reader.readLine()) != null) {
				URL reject = new URL(rejectURL);
				String fileName = reject.getFile();
				
				// remove file:/ prefix and /! suffix
				fileName  = fileName.substring(6, fileName.length() - 2);
				
				// try to delete rejects - if can't delete, add them to rejection list
				if (!deleteRejectedURL(reject)) {
					instance.localManager.logInfo("Can't delete rejected plugin " + fileName);
					instance.rejectedPlugins.add(reject);
				} else {
					instance.localManager.logInfo("Deleted rejected plugin " + fileName);
				}
			}
			
			reader.close();
			instance.localManager.logDebug("Rejection list restored");
		} catch (MalformedURLException e) {
			throw new ComponentInitializationException("Malformed rejection URL occurred during restore", e);
		} catch (IOException e) {
			throw new ComponentInitializationException("I/O error occurred during restore", e);
		}
!!!134018.java!!!	internalGetManager() : PluginManager
		return pluginManager; 
