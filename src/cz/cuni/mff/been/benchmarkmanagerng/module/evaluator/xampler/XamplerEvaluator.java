/*
 *  BEEN: Benchmarking Environment
 *  ==============================
 *
 *  File author: Jan Tattermusch
 *
 *  GNU Lesser General Public License Version 2.1
 *  ---------------------------------------------
 *  Copyright (C) 2004-2006 Distributed Systems Research Group,
 *  Faculty of Mathematics and Physics, Charles University in Prague
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License version 2.1, as published by the Free Software Foundation.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 *  MA  02111-1307  USA
 */
package cz.cuni.mff.been.benchmarkmanagerng.module.evaluator.xampler;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import cz.cuni.mff.been.benchmarkmanagerng.Configuration;
import cz.cuni.mff.been.benchmarkmanagerng.module.EvaluatorPluggableModule;
import cz.cuni.mff.been.common.Pair;
import cz.cuni.mff.been.common.rsl.Condition;
import cz.cuni.mff.been.common.rsl.ParseException;
import cz.cuni.mff.been.common.rsl.ParserWrapper;
import cz.cuni.mff.been.jaxb.td.TaskDescriptor;
import cz.cuni.mff.been.pluggablemodule.PluggableModuleManager;
import cz.cuni.mff.been.resultsrepositoryng.DatasetDescriptor;
import cz.cuni.mff.been.resultsrepositoryng.RRTrigger;
import cz.cuni.mff.been.resultsrepositoryng.condition.Restrictions;
import cz.cuni.mff.been.task.benchmarkmanagerng.evaluator.CommonEvaluatorProperties;
import cz.cuni.mff.been.taskmanager.TaskDescriptorHelper;

/**
 * Evaluator pluggable module for Xampler benchmark.
 * 
 * Accepts data from dataset created by Xampler generator.
 * 
 * xampler-evaluator-task is triggered by this evaluator's triggers 
 * once new row(s) is added to xampler_results dataset.
 * Properties of triggered task are set according to 
 * evaluator's configuration.
 * 
 * @author Jan Tattermusch
 */
public class XamplerEvaluator extends EvaluatorPluggableModule {
	
	/**
	 * name of dataset for storing results (generated by XamplerGenerator)
	 */
	private static String XAMPLER_RESULTS_DATASET_NAME = "xampler_results";
	
	/**
     * name of suite name field in xampler_results dataset
     */
    private static final String SUITE_FIELD_NAME = "suite_name";
	

    /** configuration field */
	private String benchmarkName;
	
	/** configuration field */
	private String platformName;
	
	/** configuration field */
	private String suiteName;
	
	/** configuration field */
	private String siteUrl;
	
	/** configuration field */
	private Integer dependencyId;
	
	/** configuration field */
	private String destDir;

	/** configuration field */
	private Boolean processOldData;

	/** configuration field */
	private Condition evaluationRSL;
	
	/**
	 * Creates new instance of XamplerEvaluator
	 * 
	 * @param manager pluggable module manager
	 */
	public XamplerEvaluator(PluggableModuleManager manager) {
		super(manager);
	}

	/** 
	 * 
	 * No datasets are created by XamplerEvaluator.
	 * 
	 * @see cz.cuni.mff.been.benchmarkmanagerng.module.EvaluatorPluggableModule#doCreateDatasets(cz.cuni.mff.been.benchmarkmanagerng.Configuration)
	 */
	@Override
	protected Map<String, DatasetDescriptor> doCreateDatasets(Configuration configuration) {
		
		// No datasets needed for this evaluator 
		
		return null;
	}

	/**
	 * Creates trigger that triggers 
	 * xampler-evaluator-task with appropriate properties.
	 * 
	 * @see cz.cuni.mff.been.benchmarkmanagerng.module.EvaluatorPluggableModule#doCreateTriggers()
	 */
	@Override
	protected List<RRTrigger> doCreateTriggers() {
		List<RRTrigger> triggers = new LinkedList<RRTrigger>();

		String analysisName = getAnalysis().getName();
		String datasetName = XAMPLER_RESULTS_DATASET_NAME;

		TaskDescriptor descriptor = TaskDescriptorHelper.createTask(
				"XamplerEvaluator-" + analysisName,
				"xampler-evaluator-task",
				getAnalysis().getEvaluatorContext(), 
				evaluationRSL,
				"/evaluator/xampler-" + analysisName
			);
		
		TaskDescriptorHelper.addTaskProperties(
			descriptor,
			
			Pair.pair(CommonEvaluatorProperties.ANALYSIS_NAME, analysisName),
			Pair.pair(CommonEvaluatorProperties.DATASET_NAME, datasetName),
			
			Pair.pair("benchmark.name", benchmarkName),
			Pair.pair("platform.name", platformName),
			Pair.pair("suite.name", suiteName),
			
			Pair.pair("dest.dir", destDir),
			
			Pair.pair("site.url", siteUrl),
			Pair.pair("dependency.id", dependencyId.toString()),
			
			Pair.pair("process.old.data", processOldData.toString())
		);
		
		RRTrigger trigger = new RRTrigger(
				analysisName,
				datasetName,
				"Xampler",
				
				//only trigger rows with given suite
				Restrictions.eq(SUITE_FIELD_NAME, suiteName),
				descriptor
			);
		triggers.add(trigger);

		return triggers;
	}

	/** 
	 * 
	 * Validates configuration fields.
	 * 
	 * @see cz.cuni.mff.been.benchmarkmanagerng.module.EvaluatorPluggableModule#doValidateConfiguration(cz.cuni.mff.been.benchmarkmanagerng.Configuration)
	 */
	@Override
	protected Collection<String> doValidateConfiguration(Configuration configuration) {
		
		return readConfiguration(configuration);
	}

	/**
	 * Parses integer
	 * @param s string to parse
	 * @param fieldName field name that will appear in error message
	 * @param errors error message accumulator
	 * @return number
	 */
	Integer parseInt(String s, String fieldName, List<String> errors) {
		try {
			return Integer.parseInt(s);
		} catch(NumberFormatException e) {
			errors.add("Error parsing field " + fieldName + ": " + e.getMessage());
			return null;
		}
	}
	
	
	/**
	 * Reads configuration from given object and validates it.
	 * Returns list of error messages.
	 * Read configuration is stored into this object's fields
	 * @param configuration configuration
	 * @return list of error messages or null if no error encountered
	 */
	private List<String> readConfiguration(Configuration configuration) {
		List<String> errors = new ArrayList<String>();
		
		benchmarkName = configuration.get("benchmark.name",0);
		platformName = configuration.get("platform.name",0);
		
		String suite = configuration.get("suite.name",0);
		
		String subsuite = configuration.get("subsuite.name",0);
		
		if (subsuite != null && !subsuite.trim().isEmpty()) {
			suiteName = suite + "/" + subsuite; 
		} else {
			suiteName = suite;
		}
		
		siteUrl = configuration.get("site.url",0);
		destDir = configuration.get("dest.dir",0);
		dependencyId =  parseInt(configuration.get("dependency.id",0), "dependency.id", errors);
		
		processOldData = false;
		if ("true".equals(configuration.get("process.old.data",0))) {
			processOldData = true; 
		} 
		
		evaluationRSL = parseRSLCondition(configuration.get("evaluation.host",0), "evaluation.host", errors, false);
		
		return errors;
	}
	
	/**
	 * Parses RSL condition 
	 * @param string string to parse
	 * @param fieldName field name that will appear in error message
	 * @param errors error message accumulator
	 * @return RSL condition
	 */
	private Condition parseRSLCondition(String string, String fieldName, List<String> errors, boolean allowEmpty) {
		try {
			if (allowEmpty && string == null) {
				return null;
			}
			string = string.trim();
			if (allowEmpty && string.isEmpty()) {
				return null; 
			} 
			return ParserWrapper.parseString(string);
		} catch(ParseException e) {
			errors.add("Error parsing field " + fieldName + ": " + e.getMessage());
			return null;
		} 
	}
}
