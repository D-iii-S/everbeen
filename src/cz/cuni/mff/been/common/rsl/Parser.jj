/*
 *  BEEN: Benchmarking Environment
 *  ==============================
 *
 *  File author: David Majda
 *
 *  GNU Lesser General Public License Version 2.1
 *  ---------------------------------------------
 *  Copyright (C) 2004-2006 Distributed Systems Research Group,
 *  Faculty of Mathematics and Physics, Charles University in Prague
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License version 2.1, as published by the Free Software Foundation.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 *  MA  02111-1307  USA
 */

/* RSL parser definition for javacc. */

options {
	/* Create parser with non-static method, so that multiple instances can be
	   created. */
	STATIC = false; 
}

/* ===== Parser Declaration ===== */

PARSER_BEGIN(Parser)
	package cz.cuni.mff.been.common.rsl;
	
	import java.io.PrintStream; /* Required by code generated by javacc. */
	import java.text.SimpleDateFormat;
	import java.util.List;
	import java.util.Date;
	import java.util.ArrayList;
	import java.util.regex.Pattern;
	import java.util.regex.PatternSyntaxException;
		
	import cz.cuni.mff.been.common.rsl.LongWithUnit;
	import cz.cuni.mff.been.common.Version;
	import cz.cuni.mff.been.softwarerepository.PackageType;

	@SuppressWarnings("all")
	class Parser {
		/* We're creating generic array. That's impossible without warnings.*/
		@SuppressWarnings("unchecked") 
		private <T> Condition buildSimpleCondition(String propertyPath, int operatorKind, T value) {
				switch (operatorKind) {
					case ParserConstants.EQUALS:
						return new EqualsCondition<T>(propertyPath, value);
					case ParserConstants.NOT_EQUAL:
						return new NotEqualCondition<T>(propertyPath, value);
					case ParserConstants.LESS_THAN:
						return new LessThanCondition<T>(propertyPath, value);
					case ParserConstants.LESS_OR_EQUAL:
						return new LessOrEqualCondition<T>(propertyPath, value);
					case ParserConstants.GREATER_THAN:
						return new GreaterThanCondition<T>(propertyPath, value);
					case ParserConstants.GREATER_OR_EQUAL:
						return new GreaterOrEqualCondition<T>(propertyPath, value);
					case ParserConstants.CONTAINS:
						return new ContainsCondition<T>(propertyPath, value);
					case ParserConstants.MATCHES:
						return new MatchesCondition<T>(propertyPath, value);
					case ParserConstants.DOES_NOT_MATCH:
						return new DoesNotMatchCondition<T>(propertyPath, value);
					default:
						assert false: "Invalid token kind.";
						return null; // to shut up the compiler
				}
		}
		
	}
PARSER_END(Parser)

/* ===== Lexical tokens ===== */

/* Skip whitespace and newlines. */
SKIP: { "\t" | " " }
SKIP: { "\n" | "\r" | "\r\n" }

/* Operators. */
TOKEN: { < EQUALS: "==" > }
TOKEN: { < NOT_EQUAL: "!=" > }
TOKEN: { < LESS_THAN: "<" > }
TOKEN: { < LESS_OR_EQUAL: "<=" > }
TOKEN: { < GREATER_THAN: ">" > }
TOKEN: { < GREATER_OR_EQUAL: ">=" > }
TOKEN: { < CONTAINS: "contains" > }
TOKEN: { < MATCHES: "=~" > }
TOKEN: { < DOES_NOT_MATCH: "!~" > }

/* Right-hand side of the simple conditions. */

TOKEN: { < PACKAGE_TYPE: "source" | "binary" | "task" | "data" > }

/* Unit size is limited by Long.MAX_VALUE, which is 2^63-1. This implies that
 * we don't recognize exabyte (EB, 2^60), zettabyte (ZB, 2^70) and yottabyte
 * (YB, 2^80). I don't think this matters much (unless you are running this
 * program many many years after its creation :-)
 */
TOKEN: { < #DIGITS: (["0"-"9"])+ > }
TOKEN: { < #UNIT_PREFIX: ["k", "M", "G", "T", "P"] > }
TOKEN: { < #UNIT_NAME: (["a"-"z", "A"-"Z"])+ > }
TOKEN: { < LONG: <DIGITS> (<UNIT_PREFIX>)? (<UNIT_NAME>)? > }

TOKEN: { < #VERSION_PART_CHARS: (["0"-"9", "a"-"z", "A"-"Z", "_", "-"])+ > }
TOKEN: { < VERSION: ["0"-"9"] (<VERSION_PART_CHARS>)? "." <VERSION_PART_CHARS> ("." <VERSION_PART_CHARS>)* > }

/* DATE token format is modelled after ISO 8601 and closely matches W3C's note
 * "Date and Time Formats" available at <http://www.w3.org/TR/NOTE-datetime>.
 * The only difference is that we don't allow sole year as date, because it can
 * be confused with LONG.
 */
TOKEN: { < #TZD: ("Z" | ("+" | "-") ["0"-"9"]["0"-"9"] ":" ["0"-"9"]["0"-"9"]) > }
TOKEN: { < DATE: 
	["0"-"9"]["0"-"9"]["0"-"9"]["0"-"9"]  /* Year */
	"-" ["0"-"9"]["0"-"9"]                /* Month */
	(
		"-" ["0"-"9"]["0"-"9"]            /* Day */
		(
			"T" ["0"-"9"]["0"-"9"]        /* Hours */
			":" ["0"-"9"]["0"-"9"]        /* Minutes */
			(
				":" ["0"-"9"]["0"-"9"]    /* Seconds */
				(
					"." ["0"-"9"]         /* Decimal fraction of a second */
				)?
			)? 
			< TZD >                       /* Time zone designator */
		)?
	)?
> }

/* Regular expression literals are modeled by JavaScript's Regexp class (i.e.
 * regex is wrapped inside "/" with opional flags at the end). The inner syntax
 * of the regular expression is same as in Java - this makes parsing quite easy.
 * The only flag allowed is "i", which means case-insenstive matching.
 */
TOKEN: { < PATTERN: "/" ("\\/" | ~["/"])* "/" ("i")? > }

TOKEN: { < STRING: "\"" ("\\\"" | ~["\""])* "\"" > }

/* Boolean operators. */
TOKEN: { < AND: "&&" > }
TOKEN: { < OR: "||" > }

/* Parenthesis & braces. */
TOKEN: { < LEFT_PAREN: "(" > }
TOKEN: { < RIGHT_PAREN: ")" > }
TOKEN: { < LEFT_BRACE: "{" > }
TOKEN: { < RIGHT_BRACE: "}" > }


/* Property path.

   Ordering matters! Property path definition needs to be specified after
   section "Right-hand side of the simple conditions" and "Operators", because
   some rules there conflict and we want them to win (in javacc, first matching
   rule wins).
   
   Note this makes tokens like "source", "binary" etc. effectively reserved words. */
TOKEN: { < #LETTER_OR_UNDERSCORE: (["a"-"z", "A"-"Z", "_"])+ > }
TOKEN: { < #LETTERS_OR_DIGITS_OR_UNDERSCORES: (["a"-"z", "A"-"Z", "0"-"9", "_"])+ > }
TOKEN: { < #PROPERTY_NAME: <LETTER_OR_UNDERSCORE> (<LETTERS_OR_DIGITS_OR_UNDERSCORES>)* > }
TOKEN: { < PROPERTY_PATH: <PROPERTY_NAME> ("." <PROPERTY_NAME>)* > }

/* This matches any character. It is here because now TokenMgrError will never
 * be thrown by the parser if invalid character is found - the parser will throw
 * ParseException instead.
 *
 * ParseException contains more information about the error (location in the
 * code etc.) than TokenMgrError, and so user-friendly message can be generated
 * from it. And is is a checked exception, so we can't forget to handle it.
 *
 * This trick is copied from the JavaCC FAQ:
 *
 *   <http://www.engr.mun.ca/~theo/JavaCC-FAQ/javacc-faq-moz.htm#tth_sEc3.19>
 */
TOKEN: { < UNEXPECTED_CHAR : ~[] > }

/* ===== Grammar rules ===== */

Condition Start(PrintStream printStream):
{
	Condition c;
}
{
	c = Condition() <EOF>
	{ return c; }
}

Condition Condition():
{
	Condition c;
}
{
	c = OrCondition()
	{ return c; }
}

Condition OrCondition():
{
	List<Condition> subConditions = new ArrayList<Condition>();
	Condition c;
}
{
	c = AndCondition()
	{ subConditions.add(c); }
	(
		<OR> c = AndCondition()
		{ subConditions.add(c); }
	)*
	{
		if (subConditions.size() > 1) {
			Condition[] subConditionsArray = new Condition[subConditions.size()];
			return new OrCondition(subConditions.toArray(subConditionsArray));
		} else {
			return subConditions.get(0);
		}
	}
}

Condition AndCondition():
{
	List<Condition> subConditions = new ArrayList<Condition>();
	Condition c;
}
{
	(
		LOOKAHEAD(<PROPERTY_PATH> (<EQUALS> | <NOT_EQUAL> | <LESS_THAN> | <LESS_OR_EQUAL> | <GREATER_THAN> | <GREATER_OR_EQUAL> | <CONTAINS> | <MATCHES> | <DOES_NOT_MATCH>)) c = SimpleCondition()
	| 
		LOOKAHEAD(<PROPERTY_PATH> <LEFT_BRACE>) c = QualifiedCondition()
	|
		c = SubCondition()
	)
	{ subConditions.add(c); }
	(
		<AND>
		(
			LOOKAHEAD(<PROPERTY_PATH> (<EQUALS> | <NOT_EQUAL> | <LESS_THAN> | <LESS_OR_EQUAL> | <GREATER_THAN> | <GREATER_OR_EQUAL> | <CONTAINS> | <MATCHES> | <DOES_NOT_MATCH>)) c = SimpleCondition()
		| 
			LOOKAHEAD(<PROPERTY_PATH> <LEFT_BRACE>) c = QualifiedCondition()
		|
			c = SubCondition()
		)
		{ subConditions.add(c); }
	)*
	{
		if (subConditions.size() > 1) {
			Condition[] subConditionsArray = new Condition[subConditions.size()];
			return new AndCondition(subConditions.toArray(subConditionsArray));
		} else {
			return subConditions.get(0);
		}
	}
}

Condition SimpleCondition():
{
	Token t1, t2, t3;
	Condition c = null; // assign to null to shut up the compiler
}
{
	t1 = <PROPERTY_PATH>
	(
		t2 = <EQUALS>
 	|
 		t2 = <NOT_EQUAL>
 	|
 		t2 = <LESS_THAN>
 	|
 		t2 = <LESS_OR_EQUAL>
 	|
 		t2 = <GREATER_THAN>
 	|
 		t2 = <GREATER_OR_EQUAL>
 	|
 		t2 = <CONTAINS>
 	|
 		t2 = <MATCHES>
 	|
 		t2 = <DOES_NOT_MATCH>
	)
	(
		t3 = <LONG>
		{
			c = buildSimpleCondition(t1.image, t2.kind, new LongWithUnit(t3.image));
		}
	|
		t3 = <VERSION>
		{
			c = buildSimpleCondition(t1.image, t2.kind, new Version(t3.image));
		}
	|
		t3 = <DATE>
		{
			/* We parse the date by hand, because... SimpleDateFormat was
			 * tried and was found unusable.
			 *
			 * Maybe should be cleaned up and commented a bit sometimes...
			 */
			Date date = new Date();
			date.setYear(Integer.valueOf(t3.image.substring(0, 4)) - 1900);
			date.setMonth(Integer.valueOf(t3.image.substring(5, 7)) - 1);
			if (t3.image.length() > 7) {
				date.setDate(Integer.valueOf(t3.image.substring(8, 10)));
			} else {
				date.setDate(0);
			}
			if (t3.image.length() > 10) {
				date.setHours(Integer.valueOf(t3.image.substring(11, 13)));
				date.setMinutes(Integer.valueOf(t3.image.substring(14, 16)));
			} else {
				date.setHours(0);
				date.setMinutes(0);
			}
			if (t3.image.length() > 16 && t3.image.charAt(16) != 'Z'
					&& t3.image.charAt(16) != '+' && t3.image.charAt(16) != '-') {
				date.setSeconds(Integer.valueOf(t3.image.substring(17, 19)));
			} else {
				date.setSeconds(0);
			}
			if (t3.image.length() > 19 && t3.image.charAt(19) != 'Z'
					&& t3.image.charAt(19) != '+' && t3.image.charAt(19) != '-') {
				date.setTime((date.getTime() / 1000) * 1000
					+ Integer.valueOf(t3.image.substring(20, 21)) * 100);
			} else {
				date.setTime((date.getTime() / 1000) * 1000);
			}
			
			if (t3.image.length() > 16) {
				if (t3.image.charAt(t3.image.length() - 1) == 'Z') {
					date.setTime(date.getTime() - date.getTimezoneOffset() * 60000);
				} else {
					int l = t3.image.length();
					int diff = Integer.valueOf(t3.image.substring(l - 2, l)) 
						+ Integer.valueOf(t3.image.substring(l - 5, l - 3)) * 60;
					diff = diff * 60000;
					diff = t3.image.charAt(l - 6) == '+' ? diff : -diff;
					date.setTime(date.getTime() - date.getTimezoneOffset() * 60000 - diff);
				}
			} 
			
			c = buildSimpleCondition(t1.image, t2.kind, date);
		}
	|
		t3 = <PATTERN>
		{
			boolean caseInsensitive = t3.image.charAt(t3.image.length() - 1) == 'i';
			Pattern pattern = null;
			try {
				pattern = Pattern.compile(
					t3.image
						.substring(1, t3.image.length() - (caseInsensitive ? 2 : 1))
						.replaceAll("\\\\/", "/"),
					caseInsensitive ? Pattern.CASE_INSENSITIVE : 0);
			} catch (PatternSyntaxException e) {
				throw new ParseException(e.getMessage());
			}
			c = buildSimpleCondition(t1.image, t2.kind, pattern);
		}
	|
		t3 = <STRING>
		{
			c = buildSimpleCondition(t1.image, t2.kind, t3.image
				.substring(1, t3.image.length() - 1)
				.replaceAll("\\\\\"", "\"")
			);
		}
	|
		t3 = <PACKAGE_TYPE>
		{
			c = buildSimpleCondition(t1.image, t2.kind, PackageType.realValueOf(t3.image));
		}
	)
	{ return c; }
}


Condition QualifiedCondition():
{
	Token t;
	Condition c;
}
{
	t = <PROPERTY_PATH>
	{ String qualifier = t.image; }
	<LEFT_BRACE> c = Condition() <RIGHT_BRACE>
	{ return new QualifiedCondition(qualifier, c); }
}

Condition SubCondition():
{
	Condition c;
}
{
	<LEFT_PAREN> c = Condition() <RIGHT_PAREN>
	{ return c; }
}
